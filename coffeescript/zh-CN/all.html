<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - 应用程序</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 返回目录</a></div>


<h1>创建应用程序</h1>

<p>既然你基本已经了解了CoffeeScript的语法，那现在让我们来探索下如何使用它来真枪实弹的创建应用程序。本节内容对所有的CoffeeScript开发者都有用，无论你是新人还是老手，实际上，这对只写JavaScript的人来说也非常有用。</p>

<p>不知什么原因，当开发者构建JavaScript客户端程序时，往往不会使用可靠的测试过的模式或约定，这就导致大量的代码像意大利面条一样无法维护。程序架构的重要性再怎么强调都不过分。如果你所写的JavaScript或者CoffeeScript不是表单验证这么简单的话，你需要使用某种程序架构，比方说<a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a>。</p>

<p>创建可维护的大型应用程序的秘诀就是不要做大型程序。换句话说，就是创建一系列低耦和的模块。程序逻辑越通用越好，尽量抽象出来。最终，将你的逻辑分别拆分为视图（views）、数据模型（models）和控制器（controllers）（MVC）。如何实现MVC超出了本章的范围，需要的话我建议你到<a href="http://oreilly.com/catalog/9781449307530/">JavaScript Web Applications</a>翻看我的书，或者使用像<a href="http://documentcloud.github.com/backbone/">Backbone</a> 或者 <a href="https://github.com/maccman/spine">Spine</a>这类框架。现在先不管那些，在这里我们使用CommonJS模块来构建应用程序。</p>

<h2>结构 &amp; CommonJS</h2>

<p>那什么CommonJS模块到底是什么呢？好的，如果你用过<a href="http://nodejs.org/">NodeJS</a> 的话，你大概没有意识到你在使用CommonJS模块。CommonJS模块起初是为了编写服务器端JavaScript类库而开发的，企图用它来解决模块加载、命名空间和作用域的问题。还有一个通用的形式用来兼容所有的JavaScript实现。目标是写一个给<a href="http://www.mozilla.org/rhino/">Rhino</a> 的类库也可以用于Node。终于这种思想被移植到了浏览器中，而且现在我们有像<a href="http://requirejs.org">RequireJS</a>和<a href="https://github.com/jbrantly/yabble">Yabble</a>这样好的类库来构建模块化的客户端。</p>

<p>实际上，模块能保证你的代码运行在局部作用域中（代码分装），你可以通过<code>require()</code>函数来载入模块，而且通过<code>module.exports</code>来暴露模块。让我们更加深入的研究下。</p>

<h3>导入文件</h3>

<p>你可是使用<code>require()</code>来载入其他模块和类库。只给它传递一个模块名即可，而且如果该模块正加载目录中，<code>require()</code>会返回一个代表该模块的对象。例如：</p>

<pre><code>User = require("models/user")
</code></pre>

<p>同步的<code>require</code>是一个颇具争议的问题，但是主流的类库加载器和CommonJS的预案中已经解决了这个问题。如果你不想使用我下面推荐的Stitch而想另走一条路的话，你可能需要看一下它。</p>

<h3>暴露属性</h3>

<p>默认情况下，模块不会暴露任何属性，因此模块内的东西对于<code>require()</code>调用来说不可见。如果你想访问模块的某个属性，你需要将它挂到<code>module.exports</code>：</p>

<pre><code># random_module.js
module.exports.myFineProperty = -&gt;
  # Some shizzle
</code></pre>

<p>现在，<code>require</code>这个模块的时候<code>myFineProperty</code>就会暴露出来：</p>

<pre><code>myFineProperty = require("random_module").myFineProperty
</code></pre>

<h2>使用Stitch打包</h2>

<p>把你的代码格式化为CommnonJS模块很不错，但是如何让这些模块在客户端也能工作呢？我采用<a href="https://github.com/sstephenson/stitch">Stitch</a>这个不太有名的类库作为解决方案。Stitch的作者是Sam Stephenson，其思想来自于<a href="http://www.prototypejs.org">Prototype.js</a>，非常优雅的解决了模块的问题，真让我兴奋呀！Stitch简单将所有的JavaScript文件打包到一起，巧妙的将它们包裹在CommonJS中，而不是尝试动态处理依赖。噢，我差点忘记说 ，它还能编译CoffeeScript、JS模板、<a href="http://lesscss.org">LESS CSS</a>和<a href="http://sass-lang.com">Sass</a>。</p>

<p>首先，如果你必须安装 <a href="http://nodejs.org/">Node.js</a>和<a href="http://npmjs.org/">npm</a>，如果还没有安装的话。在本章中我们要用到它们。</p>

<p>现在，创建我们的程序结构。如果你正在使用<a href="https://github.com/maccman/spine">Spine</a>，那你可以使用<a href="http://github.com/maccman/spine.app">Spine.App</a>自动生成，否则你需要手动的创建。我通常把全部的程序代码放到<code>app</code>目录下，<code>lib</code>存放通常的类库，然后包括其他一些像静态资源等等放到<code>public</code>目录中。</p>

<pre><code>app
app/controllers
app/views
app/models
app/lib
lib
public
public/index.html
</code></pre>

<p>接着，为了启动我们的Stitch服务，让我们创建一个名为<code>index.coffee</code>的文件，添加如下脚本：</p>

<p><span class="csscript"></span></p>

<pre><code>require("coffee-script")
stitch  = require("stitch")
express = require("express")
argv    = process.argv.slice(2)

package = stitch.createPackage(
  # Specify the paths you want Stitch to automatically bundle up
  paths: [ __dirname + "/app" ]

  # Specify your base libraries
  dependencies: [
    # __dirname + '/lib/jquery.js'
  ]
)
app = express.createServer()

app.configure -&gt;
  app.set "views", __dirname + "/views"
  app.use app.router
  app.use express.static(__dirname + "/public")
  app.get "/application.js", package.createServer()

port = argv[0] or process.env.PORT or 9294
console.log "Starting server on port: #{port}"
app.listen port
</code></pre>

<p>你会发现我们依赖了一些类库：<code>coffee-scirpt</code>、<code>stitch</code>和<code>express</code>。我们需要创建一个<code>package.json</code>文件，列出这些依赖类库以便npm可以将它们打包到一起。我们的<code>./package.json</code>看起来像下面这样：</p>

<pre><code>{
  "name": "app",
  "version": "0.0.1",
  "dependencies": { 
    "coffee-script": "~1.1.2",
    "stitch": "~0.3.2",
    "express": "~2.5.0",
    "eco": "1.1.0-rc-1"
  }
}
</code></pre>

<p>然后让我使用npm安装这些依赖：</p>

<pre><code>npm install .
npm install -g coffee-script
</code></pre>

<p>好，我们就要完成了，现在运行：</p>

<pre><code>coffee index.coffee
</code></pre>

<p>但愿你的stitch服务器已经运行起来了，让我继续在<code>app</code>目录中添加一个<code>app.coffee</code>脚本来测试下。这个就是将要引导启动我们程序的文件。</p>

<p><span class="csscript"></span></p>

<pre><code>module.exports = App =
  init: -&gt;
    # Bootstrap the app
</code></pre>

<p>现在让我们创建主页<code>index.html</code>，如果我们创建的是单页面程序，那它将是唯一一个我们会访问的页面。这是一个静态资源，因此将其放在<code>public</code>目录下。</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=utf-8&gt;
  &lt;title&gt;Application&lt;/title&gt;
  &lt;!-- Require the main Stitch file --&gt;
  &lt;script src="/application.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" charset="utf-8"&gt;
    document.addEventListener("DOMContentLoaded", function(){
      var App = require("app");
      App.init();
    }, false);
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>当页面加载完成，我们的<em>DOMContentLoaded</em>事件回调函数会require<code>app.coffee</code>脚本（它已经被自动编译好了），然后调用<code>init()</code>函数。其实就是这样，我们获取了一个CommonJS模块并且运行了它，就如一个HTTP服务器和CoffeeScript编译器一样。假如，我们想包含一个模块，只需调用<code>require()</code>即可。让我们创建一个新的类，<code>User</code>，在<code>app.coffee</code>中引用它：</p>

<p><span class="csscript"></span></p>

<pre><code># app/models/user.coffee
module.exports = class User
  constructor: (@name) -&gt;

# app/app.coffee
User = require("models/user")
</code></pre>

<h2>JavaScript模板</h2>

<p>如果你把逻辑都放到了客户端，那你就必须使用某种模板引擎。JavaScript模板除了它运行在客户端之外,与服务器端的模板引擎非常相似，比方说Ruby的ERB或者Python的文本插值。有很多模板类库，因此我鼓励你进行研究将它们找出来。默认地，Stitch预置了对<a href="https://github.com/sstephenson/eco">Eco</a>的支持。</p>

<p>JavaScript模板与服务端模板非常相似。你可以混合使用模板标签和HTML，在模板绘制过程中这些标签会被求值被替换。<a href="https://github.com/sstephenson/eco">Eco</a>模板最好的地方在于，它们可以直接使用CoffeeScript。</p>

<p>例如：</p>

<pre><code>&lt;% if @projects.length: %&gt;
  &lt;% for project in @projects: %&gt;
    &lt;a href="&lt;%= project.url %&gt;"&gt;&lt;%= project.name %&gt;&lt;/a&gt;
    &lt;p&gt;&lt;%= project.description %&gt;&lt;/p&gt;
  &lt;% end %&gt;
&lt;% else: %&gt;
  No projects
&lt;% end %&gt;
</code></pre>

<p>如你所见，模板语法非常明了。只需使用<code>&lt;%</code>标签来执行表达式，<code>&lt;%=</code>标签输出表达式的值。下面是一个部分模板标签的列表：</p>

<ul>
<li><p><code>&lt;% expression %&gt;</code><br/>
对一个CoffeeScript表达式求值，但不输出其返回值</p></li>
<li><p><code>&lt;%= expression %&gt;</code><br/>
对一个CoffeeScript表达式求值，转义返回值，并将其输出。</p></li>
<li><p><code>&lt;%- expression %&gt;</code><br/>
对一个CoffeeScript表达式求值，不转义，直接输出返回值。</p></li>
</ul>


<p>你可以在模板标签中使用任意的CoffeeScript表达式，但是有一点需要注意，就是虽然CoffeeScript对空格敏感，但是Eco模板不敏感。因此，Eco模板标签在开始一个CoffeeScirpt缩进块时必须使用一个冒号作为后缀。然后使用一个特殊的标签<code>&lt;% end %&gt;</code>来表示缩进块结束。例如：</p>

<pre><code>&lt;% if @project.isOnHold(): %&gt;
  On Hold
&lt;% end %&gt;
</code></pre>

<p><code>if</code>和<code>end</code>并非要写成多行：</p>

<pre><code>&lt;% if @project.isOnHold(): %&gt; On Hold &lt;% end %&gt;
</code></pre>

<p>而且你也可以使用<code>if</code>单行后缀表达式来实现：</p>

<pre><code>&lt;%= "On Hold" if @project.isOnHold() %&gt;
</code></pre>

<p>现在我们已经学习了语法，让我们在<code>views/users/show.eco</code>定义一个Eco模板吧：</p>

<pre><code>&lt;label&gt;Name: &lt;%= @name %&gt;&lt;/label&gt;
</code></pre>

<p>Stitch会自动编译我们的模板且把它们打包到<code>application.js</code>中。然后，在程序控制器中我们就可以require模板，就像使用一个模块一样，传入所以的数据执行它。</p>

<p><span class="csscript"></span></p>

<pre><code>require("views/users/show")(new User("Brian"))
</code></pre>

<p>我们的<code>app.coffee</code>文件现在看起来像下面这样，当文档加载完毕后，我们渲染这个模板并将其添加到页面中：</p>

<p><span class="csscript"></span></p>

<pre><code>User = require("models/user")

App =
  init: -&gt;
    template = require("views/users/show")
    view     = template(new User("Brian"))

    # Obviously this could be spruced up by jQuery
    element = document.createElement("div")
    element.innerHTML = view
    document.body.appendChild(element)

module.exports = App
</code></pre>

<p>访问<a href="http://localhost:9294/">http://localhost:9294/</a>，然后随便到处转转！希望这个教程能够教会你如何构建一个客户端的CoffeeScript程序。下一步，我推荐研究一些客户端模块，比方说<a href="http://documentcloud.github.com/backbone/">Backbone</a>或者<a href="http://spinejs.com">Spine</a>，它们能够为你提供一个基础的MVC框架，将你解放出来，做你感兴趣的事情。</p>

<h2>附加-使用Heroku 30秒快速发布</h2>

<p><a href="http://heroku.com/">Heroku</a>是一个非常棒的Web主机服务提供商。它为你管理所有的服务器和扩展，让你能够做自己感兴趣的事情（创建有意思的JavaScript程序）。要让本教程的实例工作你需要一个Heroku账户，好消息是它基本套餐是免费的。之前Heroku提供的是Ruby主机服务，不过现在最近它发布了它的Cedar栈，支持Node。</p>

<p>首先，我们需要创建一个<code>Profile</code>文件，用它来向Heroku提供我们的程序信息。</p>

<pre><code>echo "web: coffee index.coffee" &gt; Procfile
</code></pre>

<p>然后，你需要为你的程序创建一个本地的git代码仓库，如果你还没有创建的话。</p>

<pre><code>git init
git add .
git commit -m "First commit"    
</code></pre>

<p>现在发布程序，我们将使用<code>heroku</code>这个gem（如果你还没安装的话，你需要先安装好）。</p>

<pre><code>heroku create myAppName --stack cedar
git push heroku master
heroku open
</code></pre>

<p>好了，这样做就行了。没有比这还简单的Node主机的服务了。</p>

<h2>其他类库</h2>

<p><a href="https://github.com/sstephenson/stitch">Stitch</a>和<a href="https://github.com/sstephenson/eco">Eco</a>并不是唯一你可用于创建CoffeeScript和Node程序的类库，还有很多可作为替代的类库。</p>

<p>例如，当需要使用模板时，你可以使用 <a href="http://mustache.github.com">Mustache</a>、<a href="http://jade-lang.com">Jade</a>或者<a href="http://coffeekup.org">CoffeeKup</a>（使用纯CoffeeScript写HTML）。</p>

<p>说到为程序提供服务，<a href="http://github.com/maccman/hem">Hem</a>是比较好的选择，支持CommonJS和NPM模块，而且还无缝的集成了CoffeeScript MVC框架<a href="http://spinejs.com">Spine</a>。<a href="https://github.com/substack/node-browserify">node-browsify</a>是另外一个类似的项目。如果你想使用<a href="http://expressjs.com/">express</a>集成的更底层的东西，Trevor Burnham的<a href="https://github.com/TrevorBurnham/connect-assets">connect-assets</a>不错。</p>

<p>你可以在<a href="https://github.com/jashkenas/coffee-script/wiki/Web-framework-plugins">项目的wiki</a>上找到一个CoffeeScript Web框架插件的完整列表。</p>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - 语法</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 返回目录</a></div>


<h1>CoffeeScript语法</h1>

<p>首先，在开始本章之前，我还想重申下尽管很多时候CoffeeScript的语法与JavaScript相似，但是它并不是JavaScript的超集，因此，例如<code>function</code>和<code>var</code>这类JavaScript关键字并不允许在CoffeeScript中使用。如果你正在编写CoffeeScript文件，里面必须完全是纯CoffeeScript代码，你不能把这两种语言揉到一起。</p>

<p>为什么CoffeeScript不是超集？阻止其成为超集最直接的原因是在CoffeeScript程序中空格是有意义的。而且，既然已经这么决定了，开发团队也帮你一干到底，以精简的名字代替JavaScript的一些关键字和特性，还为避免很多常见的bug而努力。</p>

<p>让我极度兴奋的是，从元的角度上来说，CoffeeScript的解释器实际上就是由CoffeeScript写成的。这看起来似乎解决了先有鸡还是先有蛋的悖论！</p>

<p>好了，让我们从最基本的工作开始。CoffeeScript去掉了分号，它会在编译时为你自动添加。分号在JavaScript社区中引起了大量的争论，以及背后的一些解释器怪异的<a href="http://bonsaiden.github.com/JavaScript-Garden/#core.semicolon">行为</a>。总之，CoffeeScript为了帮你解决这个问题，简单地从语法上的移除了分号，然后在幕后更具需要添加。</p>

<p>注释格式与Ruby的一致，以一个哈希字符开头。</p>

<pre><code># A comment
</code></pre>

<p>也支持多行注释，而且还会把多行注释添加到生成的JavaScript中。使用三个哈希字符包裹即可。</p>

<p><span class="csscript"></span></p>

<pre><code>###
  A multiline comment, perhaps a LICENSE.
###
</code></pre>

<p>正如我简单的提过，CoffeeScript对空格是敏感的。实际说来，就是你可以使用制表符来替换花括号（{}）。这受到了Python语法的影响，而且还能确保你的脚本有一个清晰的格式，否则连编译都通不过。</p>

<h2>变量与作用域</h2>

<p>CoffeeScript修复了JavaScript中一个最让人头疼的问题——全局变量。在JavaScript中，一不小心的话，就很容易在定义变量时遗漏<code>var</code>关键字导致产生全局变量。CoffeeScript通过简单的剔除全局变量来解决这个问题。在背后，CoffeeScript使用一个匿名函数把所有脚本都包裹起来，将其限定在局部作用域中，并且为所有的变量赋值前自动添加<code>var</code>。比如，下面是在CoffeeScript中简单的定义一个变量：</p>

<p><span class="csscript"></span></p>

<pre><code>myVariable = "test"
</code></pre>

<p>注意示例代码右上角的深灰色小方块。单击它，代码就会在CoffeeScript和编译后的JavaScript之间来回切换。这是在页面加载是输出的，所以你放心，编译结果是准确的。</p>

<p>如你所见的那样，变量赋值被限定在局部作用域中，不小心创建全局变量是不可能的。CoffeeScript还更进了一步，让覆盖一个高一级的变量也很困难。这大量的减少了程序员会在JavaScript中犯的常见的错误。</p>

<p>然而，有时候全局变量还是有用的。你可以通过直接给全局对象（浏览器中的<code>window</code>）赋值来获得全局变量，也可以通过下面这种模式。</p>

<p><span class="csscript"></span></p>

<pre><code>exports = this
exports.MyVariable = "foo-bar"
</code></pre>

<p>在顶级作用域中，<code>this</code>就相当于全局对象，你可以创建一个局部变量<code>exports</code>让阅读你代码的人能够分清楚哪个是脚本创建的全局变量。而且，这还能为支持CommonJS模块铺平了道路，这在本书的后面会做介绍。</p>

<h2>函数</h2>

<p>CoffeeScript移除了冗长的<code>function</code>语句，以瘦箭头<code>-&gt;</code>替之。函数可以是一行也可以是多行。函数的最后一个表达式会作为隐式的返回值。换句话说，你不再需要使用<code>return</code>关键字，除非你想早一点从函数中返回。</p>

<p>记住这点，让我们看一个例子：</p>

<p><span class="csscript"></span></p>

<pre><code>func = -&gt; "bar"
</code></pre>

<p>结合着编译后的JavaScript你会发现，<code>-&gt;</code>被转成了一个<code>function</code>表达式，并且<code>"bar"</code>被自动的返回了。</p>

<p>前面也说了，没有理由阻止我们使用多行的函数，只需要适当地缩进函数体即可：</p>

<p><span class="csscript"></span></p>

<pre><code>func = -&gt;
  # An extra line
  "bar"
</code></pre>

<h3>函数参数</h3>

<p>如何指定参数？CoffeeScript允许你通过在箭头前面的括号中指定参数。</p>

<p><span class="csscript"></span></p>

<pre><code>times = (a, b) -&gt; a * b
</code></pre>

<p>CoffeeScript还支持默认参数，例如：</p>

<p><span class="csscript"></span></p>

<pre><code>times = (a = 1, b = 2) -&gt; a * b
</code></pre>

<p>你还可以使用参数槽（splats）接收多个参数，使用<code>...</code>表示：</p>

<p><span class="csscript"></span></p>

<pre><code>sum = (nums...) -&gt; 
  result = 0
  nums.forEach (n) -&gt; result += n
  result
</code></pre>

<p>在上面的例子中，<code>nums</code>是一个包含传递给函数全部参数的数组。它不是一个<code>arugments</code>对象，而是一个真实的数组对象，这样的话在你想操作它的时候就不需要先使用<code>Array.prototype.splice</code>或者<code>jQuery.makeArray()</code>了。</p>

<p><span class="csscript"></span></p>

<pre><code>trigger = (events...) -&gt;
  events.splice(1, 0, this)
  this.constructor.trigger.apply(events)
</code></pre>

<h3>函数调用</h3>

<p>在JavaScript中，可以通过括弧<code>()</code>、<code>apply()</code>和<code>call()</code>来调用函数。然而，像Ruby一样，如果函数被至少一个参数跟着的话，CoffeeScript会自动的调用这个函数。</p>

<p><span class="csscript"></span></p>

<pre><code>a = "Howdy!"

alert a
# Equivalent to:
alert(a)

alert inspect a
# Equivalent to:
alert(inspect(a))
</code></pre>

<p>尽管括号不是必须的，但是在难以分清谁是被调用的函数哪些是参数时，我推荐还是用上括号。上一个<code>inspect</code>的示例中，我真心建议你至少使给<code>inspect</code>的调用加上括号。</p>

<p><span class="csscript"></span></p>

<pre><code>alert inspect(a)
</code></pre>

<p>如果在调用一个函数时你没有传递参数，CoffeeScript就没有办法判断出你打算调用这个函数，还是只是把它当作一个变。从这点来看，CoffeeScript的行为与Ruby有些差异，后者总是会调用引用函数的变量，CoffeeScript更像Python。这已经变成了我的CoffeeScript程序中常见的错误。因此，在你打算无参数调用函数时多留个心眼，别忘了加上括号。</p>

<h3>函数上下文</h3>

<p>在JavaScript上下文会频繁的变化。尤其是在回调函数中，CoffeeScript为此提供了一些辅助。其中之一就是<code>-&gt;</code>的变种胖箭头的函数<code>=&gt;</code></p>

<p>使用胖箭头代替普通箭头是为了确保函数的上下文可以绑定为当前的上下文。例如：</p>

<p><span class="csscript"></span></p>

<pre><code>this.clickHandler = -&gt; alert "clicked"
element.addEventListener "click", (e) =&gt; this.clickHandler(e)
</code></pre>

<p>你之所以要这样做的原因是，来自<code>addEventListener</code>的回调函数会以<code>element</code>为上下文被调用，也就是说，<code>this</code>就相当于这个元素。如果你想让<code>this</code>等于当前上下文，除了使用<code>self=this</code>，胖箭头也是一种方式。</p>

<p>这中绑定的思想与jQuery的 <a href="http://api.jquery.com/jQuery.proxy/"><code>proxy()</code></a>或者<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">ES5's</a>的<code>bind()</code>函数是类似的概念。</p>

<h2>对象字面量与数组定义</h2>

<p>就如在JavaScript中一样，可以使用一对大括号以及键/值来明确定义对象字面量。然而，与函数调用类似，CoffeeScript使得可以省略括号。事实上，你还可以使用缩进和换行来代替起分割作用的逗号。</p>

<p><span class="csscript"></span></p>

<pre><code>object1 = {one: 1, two: 2}

# Without braces
object2 = one: 1, two: 2

# Using new lines instead of commas
object3 = 
  one: 1
  two: 2

User.create(name: "John Smith")
</code></pre>

<p>同样的，数组可以使用空格来代替分隔作用的逗号，但是方括号（<code>[]</code>）还是需要的。</p>

<p><span class="csscript"></span></p>

<pre><code>array1 = [1, 2, 3]

array2 = [
  1
  2
  3
]

array3 = [1,2,3,]
</code></pre>

<p>像你在上例看到的那样，CoffeeScript还能去掉<code>array3</code>末尾多余的逗号，这也是一个常见的跨浏览器错误源。</p>

<h2>流程控制</h2>

<p>这种可省略括号的便捷方式延续到了CoffeeScript中的<code>if</code>和<code>else</code>关键字。</p>

<p><span class="csscript"></span></p>

<pre><code>if true == true
  "We're ok"

if true != true then "Panic"

# Equivalent to:
#  (1 &gt; 0) ? "Ok" : "Y2K!"
if 1 &gt; 0 then "Ok" else "Y2K!"
</code></pre>

<p>如你所见，在单行的<code>if</code>语句中，你需要使用<code>then</code>关键字，这样CoffeeScirpt才能明白执行体从什么地方开始。CoffeeScript并不支持条件运算符，作为替代你应该使用单行的<code>if/else</code>语句。</p>

<p>CoffeeScript还支持一项Ruby的特性，即运行在<code>if</code>语句前使用前缀表达式。</p>

<p><span class="csscript"></span></p>

<pre><code>alert "It's cold!" if heat &lt; 5
</code></pre>

<p>你还可以使用<code>not</code>关键字来代替感叹号（<code>!</code>）来做取反操作。由于很容易错过感叹号，这在某些时候能让你的代码有更强的可读性。</p>

<p><span class="csscript"></span></p>

<pre><code>if not true then "Panic"
</code></pre>

<p>在上面的例子中，我们还可使使用CoffeeScript的<code>unless</code>关键字，即<code>if</code>的否定。</p>

<p><span class="csscript"></span></p>

<pre><code>unless true
  "Panic"
</code></pre>

<p>与<code>not</code>类似的风格，CoffeeScript还为大家提供了<code>is</code>语句，编译过去就是<code>===</code>。</p>

<p><span class="csscript"></span></p>

<pre><code>if true is 1
  "Type coercion fail!"
</code></pre>

<p>你可以使用<code>isnt</code>代替<code>is not</code>。</p>

<pre><code>if true isnt true
  alert "Opposite day!"
</code></pre>

<p>在上面的例子中你可以已经注意到了，CoffeeScript会把<code>==</code>操作符转化为<code>===</code>,把<code>!=</code>转化为<code>!==</code>。这是这门语言中我最喜欢的一个特性，也是最简单的一个。那这背后有什么原因呢？坦白的讲JavaScript强制的类型转换有点奇怪，并且等于操作符为了比较它们会强制类型转换，这会导致很多令人迷惑的行为和很多的bug。在第7章中还是对此有有更多的讨论。</p>

<h2>字符串插值法</h2>

<p>CoffeeScript将Ruby风格的字符串插值法引入到了JavaScript中。在双引号的字符串中可以包含<code>#{}</code>标记，这些标记中可以包含被插入到字符串中的表达式。</p>

<p><span class="csscript"></span></p>

<pre><code>favourite_color = "Blue. No, yel..."
question = "Bridgekeeper: What... is your favourite color?
            Galahad: #{favourite_color}
            Bridgekeeper: Wrong!
            "
</code></pre>

<p>就上例所示，多行字符串是允许的，不需要在没一行前添加<code>+</code>。</p>

<h2>循环和列表解析</h2>

<p>JavaScript中的数组迭代使用一种相当古老的语法，看上去更像一个类似于C之类的老语言，而不是现代的面向对象的语言。ES5引入<code>forEach()</code>函数来稍微改善了下这种情况，但是这样的话每次迭代都需要调用一次函数，因此运行速度会变慢。再一次，CoffeeScript给出一种漂亮的语法拯救了我们：</p>

<p><span class="csscript"></span></p>

<pre><code>for name in ["Roger", "Roderick", "Brian"]
  alert "Release #{name}"
</code></pre>

<p>如果你需要知道当前迭代索引的话，只需要再多传一个参数：</p>

<p><span class="csscript"></span></p>

<pre><code>for name, i in ["Roger the pickpocket", "Roderick the robber"]
  alert "#{i} - Release #{name}"
</code></pre>

<p>使用前缀的形式你可以一行代码完成迭代。</p>

<p><span class="csscript"></span></p>

<pre><code>release prisoner for prisoner in ["Roger", "Roderick", "Brian"]
</code></pre>

<p>就如Python的推导式一样，你可以过滤它们：</p>

<p><span class="csscript"></span></p>

<pre><code>prisoners = ["Roger", "Roderick", "Brian"]
release prisoner for prisoner in prisoners when prisoner[0] is "R" 
</code></pre>

<p>你可以使用推导式来迭代对象的全部属性，不过要使用<code>of</code>代替<code>in</code>关键字。</p>

<p><span class="csscript"></span></p>

<pre><code>names = sam: seaborn, donna: moss
alert("#{first} #{last}") for first, last of names
</code></pre>

<p>唯一CoffeeScript暴露出来的底层循环语法是<code>while</code>循环。它与原JavaScript中<code>while</code>循环的行为差不多，只是包含了已添加的优点，它能返回一个结果数组。看起来像<code>Array.prototype.map()</code>函数。</p>

<p><span class="csscript"></span></p>

<pre><code>num = 6
minstrel = while num -= 1
  num + " Brave Sir Robin ran away"
</code></pre>

<h2>数组</h2>

<p>说到使用区间来分割数组，CoffeeScript是受到了Ruby的影响。使用两个数字来定义区间，分别代表区间的第一个和最后一个位置。这两个数字之间使用<code>..</code>或<code>...</code>来分隔。如果区间之前没有任何东西，CoffeeScript会将其转换为一个数组。</p>

<p><span class="csscript"></span></p>

<pre><code>range = [1..5]
</code></pre>

<p>然而，如果区间被指定到一个变量之后，CoffeeScript则会将其转换为一个<code>slice()</code>调用。</p>

<p><span class="csscript"></span></p>

<pre><code>firstTwo = ["one", "two", "three"][0..1]
</code></pre>

<p>在上面的例子中，区间会返回一个只包含原始数组的前两个元素的新的字符串。你也可以使用同样的语法来把数组中的某个片段替换为其他的数组。</p>

<p><span class="csscript"></span></p>

<pre><code>numbers = [0..9]
numbers[3..5] = [-3, -4, -5]
</code></pre>

<p>更棒的是，JavaScript还能让你在字符串上调用<code>slice()</code>，因此你可以在字符串上使用区间来获得一个新的子字符串。</p>

<p><span class="csscript"></span></p>

<pre><code>my = "my string"[0..2]
</code></pre>

<p>在JavaScript中检测数组中是否存在某个值是一件麻烦事，特别是<code>indexOf()</code>并不是所有的浏览器都支持（IE，我说的就是你！）。CoffeeScript使用<code>in</code>操作符来解决这个问题，例如：</p>

<p><span class="csscript"></span></p>

<pre><code>words = ["rattled", "roudy", "rebbles", "ranks"]
alert "Stop wagging me" if "ranks" in words 
</code></pre>

<h2>别名和存在操作符</h2>

<p>CoffeeScript采用了一些有用的别名来减少输入量。其中一个就是<code>@</code>，是<code>this</code>的别名。</p>

<p><span class="csscript"></span></p>

<pre><code>@saviour = true
</code></pre>

<p>另外一个是<code>::</code>，<code>prototype</code>的别名。</p>

<p><span class="csscript"></span></p>

<pre><code>User::first = -&gt; @records[0]
</code></pre>

<p>在JavaScript中使用<code>if</code>来做<code>null</code>检查是很常见的，但是其中有几个陷阱，空字符串和零都被强制转化为<code>false</code>，这往往会让你犯错。CoffeeScript存在操作符<code>?</code>只会在变量为<code>null</code>或者<code>undefined</code>的时候会返回真，与Ruby的<code>nil?</code>类似。</p>

<p><span class="csscript"></span></p>

<pre><code>praise if brian?
</code></pre>

<p>你还能用它来替换<code>||</code>操作符：</p>

<p><span class="csscript"></span></p>

<pre><code>velocity = southern ? 40
</code></pre>

<p>如果你在访问属性之前进行<code>null</code>检查，你可以把存在操作符放在它左边来跳过检查。这与Actice Support的<a href="http://guides.rubyonrails.org/active_support_core_extensions.html#try">try</a>方法比较类似。</p>

<p><span class="csscript"></span></p>

<pre><code>blackKnight.getLegs()?.kick()
</code></pre>

<p>你能够用同样的方法检查一个属性是否是函数，是否可以调用，把存在操作符放在括号之前就行。如果属性不存在，或者不是一个函数，则就不会被调用。</p>

<p><span class="csscript"></span></p>

<pre><code>blackKnight.getLegs().kick?()
</code></pre>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - 惯用法</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 返回目录</a></div>


<h1>CoffeeScript惯用法</h1>

<p>每个语言都有自己的惯用法和最佳实践，CoffeeScript也不例外。本章将为你揭示这些常规的东西，并且为你指出一些JavaScript到CoffeeScript的变化，以便你对这门语言有个感性的认识。</p>

<h2>Each</h2>

<p>在JavaScript中我们既可以使用新加入的<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/foreach"><code>forEach()</code></a>也可以使用老的C语言风格的<code>for</code>循环来迭代一个数组。如果你打算使用一些在ECMAScript 5 提到的JavaScript新特性的话，我推荐你把这个 <a href="https://github.com/kriskowal/es5-shim">shim</a> （薄层）来模拟这些特性以便支持老的浏览器。</p>

<pre><code>for (var i=0; i &lt; array.length; i++)
  myFunction(array[i]);

array.forEach(function(item, i){
  myFunction(item)
});
</code></pre>

<p>尽管<code>forEach()</code>语法非常简洁易读，但有个缺点是在每次数组迭代时都需要调用回调函数，因此它比等价的<code>for</code>循环要慢。让我看一下这CoffeeScirpt中又是什么样子。</p>

<p><span class="csscript"></span></p>

<pre><code>myFunction(item) for item in array
</code></pre>

<p>这种语法易读简洁（我想你也这么认为），而且更棒的是这在背后会被编译为<code>for</code>循环。换句话说CoffeeScript的语法提供了<code>forEach()</code>的便捷，但是没有性能的损耗，也不需要shim的辅助。</p>

<h2>Map</h2>

<p>与<code>forEach()</code>相同，ES5包含了一个比经典<code>for</code>循环在语法上更加简洁的函数，名为 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/map"><code>map()</code></a>。不过它与<code>forEach()</code>有一样需要注意的地方，其运行速度仍会受到函数调用的拖累。</p>

<pre><code>var result = []
for (var i=0; i &lt; array.length; i++)
  result.push(array[i].name)

var result = array.map(function(item, i){
  return item.name;
});
</code></pre>

<p>如我们在<em>语法</em>这一章所说，可以使用列表解析获得与<code>map()</code>同样的行为。注意最好使用括号把列表解析包裹起来，以便能够<strong>完全地</strong>确保列表解析返回你所想要的东西——映射后的数组。</p>

<p><span class="csscript"></span></p>

<pre><code>result = (item.name for item in array)
</code></pre>

<h2>筛选</h2>

<p>ES5还提供了工具函数 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/filter"><code>filter()</code></a> 来过滤数组：</p>

<pre><code>var result = []
for (var i=0; i &lt; array.length; i++)
  if (array[i].name == "test")
    result.push(array[i])

result = array.filter(function(item, i){
  return item.name == "test"
});
</code></pre>

<p>CoffeeScript的基础语法使用<code>when</code>关键字通过一个比较来过滤数组项。在背后会产生一个<code>for</code>循环，整个运行过程都包裹在一个匿名函数中，以防止作用域泄漏或变量冲突。</p>

<p><span class="csscript"></span></p>

<pre><code>result = (item for item in array when item.name is "test")
</code></pre>

<p>别忘了使用括号，否则<code>result</code>是数组的最后一项。<br/>
CoffeeScript的列表解析是如此的灵活，允许你如下例这样做出强大地选择：</p>

<p><span class="csscript"></span></p>

<pre><code>passed = []
failed = []
(if score &gt; 60 then passed else failed).push score for score in [49, 58, 76, 82, 88, 90]

# Or
passed = (score for score in scores when score &gt; 60)
</code></pre>

<p>如果列表解析太长，你可以将它们分割成多行。</p>

<p><span class="csscript"></span></p>

<pre><code>passed = []
failed = []
for score in [49, 58, 76, 82, 88, 90]
  (if score &gt; 60 then passed else failed).push score
</code></pre>

<h2>包含</h2>

<p>通常使用<code>indexOf()</code>来测试一个数组中是否包含某个值。不过真让人惊讶, Internet Explorer并没有实现该函数，这还要做一些兼容。</p>

<pre><code>var included = (array.indexOf("test") != -1)
</code></pre>

<p>于此CoffeeScript有一个非常给力的替代方法，Python程序员一定很熟悉，名叫<code>in</code>。</p>

<p><span class="csscript"></span></p>

<pre><code>included = "test" in array
</code></pre>

<p>在背后，CoffeeScript使用的是 <code>Array.prototype.indexOf()</code>，必要的话提供shim方法来检测数组中是否有某个特定值，不幸的的是同样的<code>in</code>语法并不能在字符串中工作。我们退回去使用<code>indexOf()</code>函数，查看其返回值是否是负值：</p>

<p><span class="csscript"></span></p>

<pre><code>included = "a long test string".indexOf("test") isnt -1
</code></pre>

<p>或者更好一点，借助于位操作符我们就不用与<code>-1</code>进行比较了。</p>

<p><span class="csscript"></span></p>

<pre><code>string   = "a long test string"
included = !!~ string.indexOf "test"
</code></pre>

<h2>属性迭代</h2>

<p>在JavaScript中，你应该使用<code>in</code>操作符来迭代属性集，例如：</p>

<pre><code>var object = {one: 1, two: 2}
for(var key in object) alert(key + " = " + object[key])
</code></pre>

<p>然而，如你在上一小节所知，CoffeeScript已把<code>in</code>关键字留给了数组用。作为替代，该操作符更名为<code>of</code>，可以像下面这样用：</p>

<p><span class="csscript"></span></p>

<pre><code>object = {one: 1, two: 2}
alert("#{key} = #{value}") for key, value of object
</code></pre>

<p>如你所见，你可以同时指定属性名和属性值，非常方便。</p>

<h2>Min/Max</h2>

<p>这个技巧虽然不是CoffeeScript的专利，但是我觉得它非常有用，值得一提。<code>Math.max</code> 和<code>Math.min</code>接受多个参数，因此你可以简单的地使用<code>...</code>来向它们传递数组，从中检索出最大值和最小值。</p>

<p><span class="csscript"></span></p>

<pre><code>Math.max [14, 35, -7, 46, 98]... # 98
Math.min [14, 35, -7, 46, 98]... # -7
</code></pre>

<p>请注意，这个技巧对于超大的数组也会失败，因为浏览器对传递个函数的参数数量有限制。</p>

<h2>多个参数</h2>

<p>在上面的<code>Math.max</code>示例中，我们使用<code>...</code>来结构数组作为多个参数传递给<code>max</code>方法。在背后，CoffeeScript将其转化为一个使用<code>appply()</code>的函数调用，以确保数组能够作为多个参数传递给<code>max</code>。在别的地方也可以使用这个特性，比方说代理函数：</p>

<p><span class="csscript"></span></p>

<pre><code>Log =
  log: -&gt;
    console?.log(arguments...)
</code></pre>

<p>或者在参数继续传递下去之前，修改参数：</p>

<p><span class="csscript"></span></p>

<pre><code>Log =
  logPrefix: "(App)"

  log: (args...) -&gt;
    args.unshift(@logPrefix) if @logPrefix
    console?.log(args...)
</code></pre>

<p>不过请记住，CoffeeScript会自动把函数的调用上下文设置为调用它的对象。在上例中，就是<code>console</code>对象，如果你想设置特殊的上下文，那你需要手动的调用<code>apply()</code>方法。</p>

<h2>And/or</h2>

<p>CoffeeScript编程风格推荐使用<code>or</code>代替<code>||</code>，使用<code>and</code>代替<code>&amp;&amp;</code>。我知道为什么，因为前者看起来更直观。不过，这两种编程风格产生的结果都一样。</p>

<p>偏爱英语风格的代码的话，也可以使用<code>is</code>代替<code>==</code>，<code>isnt</code>代替<code>!=</code>。</p>

<p><span class="csscript"></span></p>

<pre><code>string = "migrating coconuts"
string == string # true
string is string # true
</code></pre>

<p>CoffeeScript还有另外一个非常好的扩展，Ruby程序员可将其看作像是<code>||=</code>这样的模式：</p>

<p><span class="csscript"></span></p>

<pre><code>hash or= {}
</code></pre>

<p>如果<code>hash</code>求值为<code>false</code>，则把它设置为一个空对象。在这里需要注意，表达式<code>0</code>、<code>""</code>和<code>null</code>都会被当作<code>false</code>。如果这并不是你想要的，那你应该使用CoffeeScript的存在操作符，这样只有<code>hash</code>是<code>undefined</code>或者<code>null</code>时才会触发。</p>

<p><span class="csscript"></span></p>

<pre><code>hash ?= {}
</code></pre>

<h2>解构赋值</h2>

<p>解构赋值对任意深度嵌套的数组或对象都适用，方便从嵌套的属性中抽取值。</p>

<p><span class="csscript"></span></p>

<pre><code>someObject = { a: 'value for a', b: 'value for b' }
{ a, b } = someObject
console.log "a is '#{a}', b is '#{b}'"
</code></pre>

<p>这在Node程序中引入模块时尤其有用：</p>

<p><span class="csscript"></span></p>

<pre><code>{join, resolve} = require('path')

join('/Users', 'Alex')
</code></pre>

<h2>其他类库</h2>

<p>既然所有的东西都会编译为JavaScript，那么使用其他类库与调用CoffeeScript类库的函数并没有什么差别。在CoffeeScript中使用 <a href="http://jquery.com">jQuery</a>显得非常优雅，因为jQuery的API中有很多回调函数。</p>

<p><span class="csscript"></span></p>

<pre><code># Use local alias
$ = jQuery

$ -&gt;
  # DOMContentLoaded
  $(".el").click -&gt;
    alert("Clicked!")
</code></pre>

<p>既然CoffeeScript编译输出的所有代码都被包裹在一个匿名函数中，因此我们可以使用一个局部变量<code>$</code>来代替<code>jQuery</code>。就算在jQuery的<code>no confict</code>模式或者<code>$</code>被重定义的情况下，我们的脚本能按预想的一样正常工作。</p>

<h2>私有变量</h2>

<p>CoffeeScript中的<code>do</code>关键字能够让我们立即运行函数，这是一种非常有效的包装作用域和受保护变量的方式。在下面的例子中，我在被<code>do</code>立刻调用的匿名函数的上下文中定义了一个变量<code>classToType</code>。该匿名函数返回了另外一个匿名函数，它才是<code>type</code>最终的值。既然<code>classType</code>是在一个不保存引用的上下文中，因此在外部作用域中不可访问。</p>

<p><span class="csscript"></span></p>

<pre><code># Execute function immediately
type = do -&gt;
  classToType = {}
  for name in "Boolean Number String Function Array Date RegExp Undefined Null".split(" ")
    classToType["[object " + name + "]"] = name.toLowerCase()

  # Return a function
  (obj) -&gt;
    strType = Object::toString.call(obj)
    classToType[strType] or "object"
</code></pre>

<p>换句话说，<code>classToType</code>是完全私有的，并且在匿名函数执行完毕之后就不能在外面作用域中引用它了。这是一种非常好的包装作用域和变量的办法。</p>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - 介绍</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 返回目录</a></div>


<h1>CoffeeScirpt是什么？</h1>

<p><a href="http://coffeescript.org">CoffeeScript</a>是一门小巧的语言，会编译为JavaScript。它的语法风格受到了Ruby和Python影响，很多特性都借鉴于这两种语言。我们写作本书的目的在于帮助你学习CoffeeScript，明白最佳实践是什么，以及帮助你开始创建有意思的客户端程序。这本书很小，仅仅只有五章，但是对与CoffeeScript这门小语言来说已足够。</p>

<p>这本书是完全开源的，作者是<a href="http://alexmaccaw.co.uk">Alex MacCaw</a> (或者 <a href="http://twitter.com/maccman">@maccman</a>)，<a href="https://github.com/dxgriffiths">David Griffiths</a>、<a href="http://github.com/satyr">Satoshi Murakami</a>和 <a href="https://github.com/jashkenas">Jeremy Ashkenas</a>也做了不小的贡献。</p>

<p>如果你有任何勘误和建议，千万别吝啬到本书的<a href="https://github.com/arcturo/library">GitHub page</a>发个ticket。或许你们还对我的另外一本书感<a href="http://oreilly.com/catalog/9781449307530/">JavaScript Web Applications by O'Reilly</a>兴趣，我在该书中对富JavaScript应用以及如何把状态转移到客户端进行了探索。</p>

<p>好了，开始我们的CoffeeScript探索之旅吧。为什么CoffeeScript要比原生的JavaScript好？首先，能够少写代码——CoffeeScript非常简洁，充分地利用空格。以我的经验来看，比起纯JavaScript的话，它能减少三分之一到一半的代码量。还有，CoffeeScript开有一些优雅的特性，比方说列表解析、原型符号别名和类等等，能够有效的减少需要你的输入。</p>

<p>更重要的是，JavaScript有很多不为人知的 <a href="http://bonsaiden.github.com/JavaScript-Garden/">秘密</a>，这些秘密往往让无经验的开发者摔跤。CoffeeScript有原则地选择了一些JavaScript的特性，巧妙地避开了这些不足，解决了该语言的怪癖。</p>

<p>CoffeeScript<em>不是</em>JavaScript的超集，因此尽管你可以在CoffeeScript中的使用外部的JavaScript类库，但是如果你在没有转化之前而直接编译当前的JavaScript的话，会出现语法错误。编译器会把CoffeeScript代码转化为相对于的JavaScript，这样在运行时就不需要解释了。</p>

<p>首先澄清一些误解。由于处理运行时错误需要JavaScript相关的知识，要写CoffeeScript就得了解JavaScript。但是话说回来，运行时错误通常比较明显，并且到目前位置，我没觉得从JavaScript映射到CoffeeSCript会有什么问题。第二个问题是我经常听到CoffeeScript相关的话题是速度。即，CoffScript编译后的JavaScript运行起来相比与之等价的纯JavaScript代码要慢。但实际情况证明并不是问题。CoffeeScript看起来与徒手写的JavaScript代码运行速度相当，甚至更快。</p>

<p>CoffeeScript的劣势是什么？是的，在你和JavaScript之间介多了编译这一步。CoffeeScript也在尝试尽力通过产生优雅的可读性强的JavaScript，以及在服务器端集成自动编译来弥补这个问题。另外一个缺陷是，作为一个新的语言，事实上现阶段社区也还比较小，想找个懂这门语言的合伙人会花费你的大量你的时间。当然，CoffeeScript发展迅猛，相关的IRC列表也是人才济济，如果你有什么问题的话，都会得到迅速的解答。</p>

<p>CoffeeScript的用途并不仅限于浏览器，把它用在JavaScript实现的服务端也非常不错，比方说在 <a href="http://nodejs.org/">Node.js</a>上。还有，CoffeeScript越来越广泛，有更多的集成，比方说它已经是Rails3.1的标配。现在正是进入CoffeeScript学习的时机。你现在为学习这门语言付出的时间在以后会以为你节约大量的时间作为回报的。</p>

<h2>初始化安装</h2>

<p>一种尝试这个类库最简单的方式就是直接在浏览器中使用它，访问<a href="http://coffeescript.org">http://coffeescript.org</a>，点击<em>Try CoffeeScript</em>标签。这个网站使用浏览器版的CoffeeScript编译器，把在左边面板任意输入的CoffeeScript代码编译为JavaScriprt后显示在右边的面板中。</p>

<p>你也可以使用<a href="http://coffee2js.org">coffee2js</a>项目把JavaScript转变为CoffeeScirpt。这在把JavaScript项目迁移到CoffeeScript上时尤其有用。</p>

<p>实际上，你自己都可以使用基于浏览器的CoffeeScirpt编译器，只需要在页面中包含<a href="http://jashkenas.github.com/coffee-script/extras/coffee-script.js">这个脚本</a>，使用正确类型（type）的标标签记CoffeeScript脚本即可。</p>

<pre><code>&lt;script src="http://jashkenas.github.com/coffee-script/extras/coffee-script.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;script type="text/coffeescript"&gt;
  # Some CoffeeScript
&lt;/script&gt;
</code></pre>

<p>显然，在生产环境中，由于会减慢客户端的运行，所以没人愿意在运行时解释执行CoffeeScript。作为替代，CoffeeScript提供了一个<a href="http://nodejs.org">Node.js</a>版的编译器来对CoffeeScript文件进行预处理。</p>

<p>要安装该编译器，首先必须保证你已经有了稳定可用的<a href="http://nodejs.org/">Node.js</a>和<a href="http://npmjs.org/">npm</a>（Node程序包管理工具）。然后你就可以使用npm来安装CoffeeScirpt了：</p>

<pre><code>npm install -g coffee-script
</code></pre>

<p>这同时还为你提供了一个<code>coffee</code>的可执行二进制程序，如果不用任何命令行参数而直接运行该程序，它会给你一个CoffeeScript的命令行，这个命令行你可以用来快速的运行一些CoffeeScript语句。要预处理文件的话，使用<code>--compile</code>参数：</p>

<pre><code>coffee --compile my-script.coffee
</code></pre>

<p>如果没有指定<code>--output</code>参数，CoffeeScript会直接将编译后的代码写入到一个同名的JavaScript文件中，本例中就是<code>my-script.js</code>。已存在该文件的话会被复写掉，因此要当心你的JavaScript文件被覆盖。使用<code>--help</code>参数可以看到一个完整的可用命令行参数列表。</p>

<p>就如你在之前看到的一样，CoffeeScirpt文件的默认扩展名是<code>.coffee</code>，除去其他原因之外，能让像<a href="http://macromates.com/">TextMate</a>这样的编译器能够辨认出文件中包含的是什么语言的代码从而是用相对应的高亮也是其中之一。TextMate并不包含对CoffeeScript的支持，但是你可以安装这个<a href="https://github.com/jashkenas/coffee-script-tmbundle">包</a>来提供支持。</p>

<p>编译看起来既不方便又很无聊。没办法，它就是这样。我们将会学习通过自动编译的方法来解决这个问题，不过首先我们先学习一下这门语言的语法。</p>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - 类</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 返回目录</a></div>


<h1>类</h1>

<p>JavaScript中的类对于纯粹主义者来说有点像大蒜对Dracula的感觉，诚实点吧，如果你喜欢那样的方式，那你应该不会想读这本关于CoffeeScript的书。可事实是类在JavaScript中就如在其他语言中一样地有用。因此，CoffeeScript为此提供了一个很棒的抽象。</p>

<p>在背后，CoffeeScript使用JavaScript原生的原型来产生类，为静态变量继承以及上下文持久化添加了一点语法糖，而暴露给开发者的全部只有一个<code>class</code>关键字。</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
</code></pre>

<p>在上例中，<code>Animal</code>是类的名字，而且也是你可以用来创建实例的合成的变量的名字。CoffeeScript在背后使用了一个构造函数，这意味着你可以使用<code>new</code>关键字来实例化变量。</p>

<p><span class="csscript"></span></p>

<pre><code>animal = new Animal
</code></pre>

<p>定义构造函数（在实例化前调用的函数）很简单，使用名为<code>constructor</code>的函数即可。这与Ruby的<code>initialize</code>或者Python的<code>__init__</code>类似。</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  constructor: (name) -&gt;
    @name = name
</code></pre>

<p>实际上，CoffeeScript为设置实例属性值的常见模式提供了一种简写的方式。如果在参数前加一个<code>@</code>，CoffeeScript就会在构造函数中自动地把参数设置为实例的属性。而且，这中简写对于类之外的普通函数同样适用。下面的例子与我们手动设置实例属性的上一例子等价。</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  constructor: (@name) -&gt;
</code></pre>

<p>如你所愿，每个实例化传入的参数都被代理给了构造函数。</p>

<p><span class="csscript"></span></p>

<pre><code>animal = new Animal("Parrot")
alert "Animal is a #{animal.name}"
</code></pre>

<h2>实例属性</h2>

<p>可以非常直接地为类添加实例属性，与为对象添加属性的语法一样。只需要在类体内对属性采用合理的缩进即可。</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  price: 5

  sell: (customer) -&gt;

animal = new Animal
animal.sell(new Customer)
</code></pre>

<p>在JavaScript中上下文变化很频繁，在上一章<em>语法</em>中我们讨论过CoffeeScript如何通过胖箭头函数（<code>=&gt;</code>）来让<code>this</code>值锁定到某个特定的上下文中。这样无论这个函数在什么上下文中被调用，都保证该函数总是在其创建时的上下文中执行。CoffeeScript把胖箭头语法扩展到类中，因此在实例方法上使用胖箭头你就能确保方法能在正确的上下文中执行——<code>this</code>总是等于当前的实例对象。</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  price: 5

  sell: =&gt;
    alert "Give me #{@price} shillings!"

animal = new Animal
$("#sell").click(animal.sell)
</code></pre>

<p>如上例所示，这在事件回调是尤其有用。正常情况下<code>sell()</code>函数会以<code>#sell</code>元素为上下文调用。然而，通过使用胖箭头来定义<code>sell()</code>，我们能保证能保持正确的上下文，所以<code>this.price</code>等于<code>5</code>。</p>

<h2>静态变量</h2>

<p>可以定义类（静态）变量吗？当然，事实证明在类的定义中，<code>this</code>引用的就是类。也就是说你可以通过直接在这个<code>this</code>上设置类属性。</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  this.find = (name) -&gt;      

Animal.find("Parrot")
</code></pre>

<p>实际上，如你所知，CoffeeScript使用<code>@</code>作为<code>this</code>的别名，这能让你更加便捷的定义静态属性：</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  @find: (name) -&gt;

Animal.find("Parrot")
</code></pre>

<h2>继承与Super</h2>

<p>不支持继承不能算是一个完整的类实现。当然CoffeeScript不会让你失望，你可以使用<code>extends</code>关键字来使用继承。在下面的例子中，<code>Parrot</code>扩展自<code>Animal</code>，继承它的实例的所有属性，比方说<code>alive()</code>方法。</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  constructor: (@name) -&gt;

  alive: -&gt;
    false

class Parrot extends Animal
  constructor: -&gt;
    super("Parrot")

  dead: -&gt;
    not @alive()
</code></pre>

<p>在上例中，你注意到我们使用了<code>super()</code>关键字。在背后这会编译为对父类原型的一次函数调用，不过是以当前为上下文的。在本例中，就相当于<code>Parrot.__super__.constructor.call(this, "Parrot");</code>。实际上，这与Ruby或者Python中调用<code>super</code>的效果相同——调用被重写了的父类函数。</p>

<p>除非你重写了<code>contructor</code>，默认情况下，在一个实例被创建时CoffeeScript会调用其父类的构造器。</p>

<p>CoffeeSript使用原型继承来自动的从类实例上继承所有的属性，这保证了类的动态性。就算你给一个已经被子类继承了的父类添加属性，这些属性仍然可以被其子类继承过来。</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  constructor: (@name) -&gt;

class Parrot extends Animal

Animal::rip = true

parrot = new Parrot("Macaw")
alert("This parrot is no more") if parrot.rip
</code></pre>

<p>值得一提的是，静态变量是直接拷贝给子类的，而不是像实例属性那样通过原型来实现。这都是JavaScript原型架构的实现细节所致，而且这是一个比较难解决的问题。</p>

<h2>Mixins</h2>

<p>CoffeeScript并不直接提供对<a href="http://en.wikipedia.org/wiki/Mixin">Mixins</a>的支持，理由是你自己完全可以很容易的实现。例如，下面有两个函数，<code>extend()</code>和<code>include()</code>分别会把类属性和实例属性添加到一个类中。</p>

<p><span class="csscript"></span></p>

<pre><code>extend = (obj, mixin) -&gt;
  obj[name] = method for name, method of mixin        
  obj

include = (klass, mixin) -&gt;
  extend klass.prototype, mixin

# Usage
include Parrot,
  isDeceased: true

(new Parrot).isDeceased
</code></pre>

<p>在继承不合适时Mixins是一种不错的在模块间共享通用逻辑的的模式。较之于继承只能实现从单一的父类继承，Mixins的优势是能够实现多个继承。</p>

<h2>扩展类</h2>

<p>Mixins很棒，只是看起来并不那么地面向对象。让我们把Mixins集成到CoffeeScript的类中吧。我们将会定义一个名为<code>Module</code>的类，然后可以继承这个类来获得对Mixins的支持。<code>Module</code>会有两个静态方法，<code>@extend()</code>和<code>@include()</code>，可以用它们来实现对类的静态属性和实例属性的扩展。</p>

<p><span class="csscript"></span></p>

<pre><code>moduleKeywords = ['extended', 'included']

class Module
  @extend: (obj) -&gt;
    for key, value of obj when key not in moduleKeywords
      @[key] = value

    obj.extended?.apply(@)
    this

  @include: (obj) -&gt;
    for key, value of obj when key not in moduleKeywords
      # Assign properties to the prototype
      @::[key] = value

    obj.included?.apply(@)
    this
</code></pre>

<p>这里有个小技巧，当使用Mixins来扩展一个类时，<code>moduleKeywords</code>变量能为我们提供了回调支持。让我们实际看一下<code>Module</code>是如何工作的：</p>

<p><span class="csscript"></span></p>

<pre><code>classProperties = 
  find: (id) -&gt;
  create: (attrs) -&gt;

instanceProperties =
  save: -&gt; 

class User extends Module
  @extend classProperties
  @include instanceProperties

# Usage:
user = User.find(1)

user = new User
user.save()
</code></pre>

<p>如你所见，我们为<code>User</code>类添加了<code>find()</code>和<code>create()</code>静态属性，还添加了<code>save()</code>实例属性。</p>

<p>既然在扩展模块后我们还可以使用回调函数，于是可以快捷地处理类属性和实例属性。</p>

<p><span class="csscript"></span></p>

<pre><code>ORM = 
  find: (id) -&gt;
  create: (attrs) -&gt;
  extended: -&gt;
    @include
      save: -&gt; 

class User extends Module
  @extend ORM
</code></pre>

<p>超简单也超优雅，有没有！</p>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - The Bad Parts</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; Back to all chapters</a></div>


<h1>The Bad Parts</h1>

<p>JavaScript is a tricky beast, and knowing the parts that you should avoid is just as important as knowing about the parts you should use. As Sun Tzu says, "know your enemy", and that's exactly what we're going to do in the chapter, exploring the dark side of JavaScript and revealing all the lurking monsters ready to pounce on the unsuspecting developer.</p>

<p>As I mentioned in the introduction, CoffeeScript's awesomeness lies not only in it's syntax, but in it's ability to fix some of JavaScript's warts. However, due to the fact that CoffeeScript statements have a direct translation into JavaScript, and don't run in a virtual machine or interpreter, the language is not a silver bullet to all of JavaScript's bugbears and there's still some issues you need to be aware about.</p>

<p>First, let's talk about what things the language does solve.</p>

<h2>A JavaScript Subset</h2>

<p>CoffeeScript's syntax only covers a subset of JavaScript's, the famous <em>Good Parts</em>, so already there's less to fix. Let's take the <code>with</code> statement for example. This statement has for a long time been "considered harmful", and should be avoided. <code>with</code> was intended to provide a shorthand for writing recurring property lookups on objects. For example, instead of writing:</p>

<pre><code>dataObj.users.alex.email = "info@eribium.org";
</code></pre>

<p>You could write:</p>

<pre><code>with(dataObj.users.alex) {
  email = "info@eribium.org";
}
</code></pre>

<p>Setting aside the fact that we shouldn't have such a deep object in the first place, the syntax is quite clean. Except for one thing. It's damn confusing to the JavaScript interpreter - it doesn't know exactly what you're going to do in the <code>with</code> context, and forces the specified object to be searched first for all name lookups.</p>

<p>This really hurts performance and means the interpreter has to turn off all sorts of JIT optimizations. Additionally <code>with</code> statements can't be minified using tools like <a href="https://github.com/mishoo/UglifyJS">uglify-js</a>. They're also deprecated and removed from future JavaScript versions. All things considered, it's much better just to avoid using them, and CoffeeScript takes this a step further by eliminating them from it's syntax. In other words, using <code>with</code> in CoffeeScript will throw a syntax error.</p>

<h2>Global variables</h2>

<p>By default, your JavaScript programs run in a global scope, and by default any variables created are in that global scope. If you want to create a variable in the local scope, JavaScript requires explicitly indicating that fact using the <code>var</code> keyword.</p>

<pre><code>usersCount = 1;        // Global
var groupsCount = 2;   // Global

(function(){              
  pagesCount = 3;      // Global
  var postsCount = 4;  // Local
})()
</code></pre>

<p>This is a bit of an odd decision since the vast majority of the time you'll be creating local variables not global, so why not make that the default? As it stands, developers have to remember to put <code>var</code> statements before any variables they're initializing, or face weird bugs when variables accidentally conflict and overwrite each other.</p>

<p>Luckily CoffeeScript comes to your rescue here by eliminating implicit global variable assignment entirely. In other words, the <code>var</code> keyword is reserved in CoffeeScript, and will trigger a syntax error if used. Local variables are created implicitly by default, and it's very difficult to create global variables without explicitly assigning them as properties on <code>window</code>.</p>

<p>Let's have a look at an example of CoffeeScript's variable assignment:</p>

<p><span class="csscript"></span></p>

<pre><code>outerScope = true
do -&gt;
  innerScope = true
</code></pre>

<p>Compiles down to:</p>

<pre><code>var outerScope;
outerScope = true;
(function() {
  var innerScope;
  return innerScope = true;
})();
</code></pre>

<p>Notice how CoffeeScript initializes variables (using <code>var</code>) automatically in the context their first used. Whilst it's impossible to shadow outer variables, you can still refer to and access them. You need to watch out for this, be careful that you're not reusing the name of an external variable accidentally if you're writing a deeply nested function or class. For example, here we're accidentally overwriting the <code>package</code> variable in a Class function:</p>

<p><span class="csscript"></span></p>

<pre><code>package = require('./package')

class Hem
  build: -&gt;
    # Overwrites outer variable!
    package = @hemPackage.compile()

  hemPackage: -&gt;
    package.create()
</code></pre>

<p>Global variables are needed from time to time, and to create those you need to set them as properties on <code>window</code>:</p>

<p><span class="csscript"></span></p>

<pre><code>  class window.Asset
    constructor: -&gt;
</code></pre>

<p>By ensuring global variables are explicit, rather than implicit, CoffeeScript removes one of the major sources of bugs in JavaScript programs.</p>

<h2>Semicolons</h2>

<p>JavaScript does not enforce the use of semicolons in source code, so it's possible to omit them. However, behind the scenes the JavaScript compiler still needs them, so the parser automatically inserts them whenever it encounters a parse error due to a missing semicolon. In other words, it'll try to evaluate a statement without semicolons and, if that fails, tries again using semicolons.</p>

<p>Unfortunately this is a tremendously bad idea, and can actually change the behavior of your code. Take the following example, seems valid JavaScript, right?</p>

<pre><code>function() {}
(window.options || {}).property
</code></pre>

<p>Wrong, well at least according to the parser; it raises a syntax error. In case of a leading parenthesis, the parser will not insert a semicolon. The code gets transformed onto one line:</p>

<pre><code>function() {}(window.options || {}).property
</code></pre>

<p>Now you can see the issue, and why the parser is complaining. When you're writing JavaScript, you should always include semicolons after statements. Fortunately CoffeeScript gets round all this hassle by not having semicolons in its syntax. Rather the semicolons are inserted automatically (at the right places) when the CoffeeScript is compiled down to JavaScript.</p>

<h2>Reserved words</h2>

<p>Certain keywords in JavaScript are reserved for future versions of JavaScript, such as <code>const</code>, <code>enum</code> and <code>class</code>. Using these as variable names in your JavaScript programs can unpredictable results; some browsers will cope with them just fine, and others will choke. CoffeeScript neatly sidesteps this issue, by detecting if you're using a reserved keyword, and escaping it if necessary.</p>

<p>For example, let's say you were to use the reserved keyword <code>class</code> as a property on an object, your CoffeeScript might look like this:</p>

<p><span class="csscript"></span></p>

<pre><code>myObj = {
  delete: "I am a keyword!"
}
myObj.class = -&gt;
</code></pre>

<p>The CoffeeScript parser notices you're using a reserved keyword, and quotes it for you:</p>

<pre><code>var myObj;
myObj = {
  "delete": "I am a keyword!"
};
myObj["class"] = function() {};
</code></pre>

<h2>Equality comparisons</h2>

<p>The weak equality comparison in JavaScript has some confusing behavior and is often the source of confusing bugs. The example below is taken from <a href="http://bonsaiden.github.com/JavaScript-Garden/#types.equality">JavaScript Garden's equality section</a> which delves into the issue in some depth.</p>

<p><span class="csscript"></span></p>

<pre><code>""           ==   "0"           // false
0            ==   ""            // true
0            ==   "0"           // true
false        ==   "false"       // false
false        ==   "0"           // true
false        ==   undefined     // false
false        ==   null          // false
null         ==   undefined     // true
" \t\r\n"    ==   0             // true
</code></pre>

<p>The reason behind this behavior is that the weak equality coerces types automatically. I'm sure you'll agree this is all pretty ambiguous, and can lead to unexpected results and bugs.</p>

<p>The solution is to instead use the strict equality operator, which consists of three equal signs: <code>===</code>. It works exactly like the normal equality operator, but without any type coercion. It's recommended to always use the strict equality operator, and explicitly convert types if needs be.</p>

<p>CoffeeScript solves this by simply replacing all weak comparisons with strict ones, in other words converting all <code>==</code> comparators into <code>===</code>. You can't do a a weak equality comparison in CoffeeScript, and you should explicitly convert types before comparing them if necessary.</p>

<p>This doesn't mean you can ignore type coercion in CoffeeScript completely though, especially when it comes to checking the 'truthfulness' of variables during flow control. Blank strings, <code>null</code>, <code>undefined</code> and the number <code>0</code> are all coerced to <code>false</code></p>

<p><span class="csscript"></span></p>

<pre><code>alert("Empty Array")  unless [].length
alert("Empty String") unless ""
alert("Number 0")     unless 0
</code></pre>

<p>If you want to explicitly check for <code>null</code> and <code>undefined</code>, then you can use CoffeeScript's existential operator:</p>

<p><span class="csscript"></span></p>

<pre><code>alert("This is not called") unless ""?
</code></pre>

<p>The <code>alert()</code> in the previous example won't be called, as the empty string isn't equal to <code>null</code>.</p>

<h2>Function definition</h2>

<p>Oddly enough in JavaScript, functions can be defined after they're used. For example, the following runs absolutely fine, even though <code>wem</code> is defined after it's called:</p>

<pre><code>wem();
function wem() {}
</code></pre>

<p>The is because of function scope. Functions get hoisted before the programs execution and as such are available everywhere in the scope they were defined in, even if called before the actual definition in the source. The trouble is, hoisting behavior differs between browser; for example:</p>

<pre><code>if (true) {
  function declaration() {
    return "first";
  }
} else {
  function declaration() {
    return "second";
  }
}
declaration();
</code></pre>

<p>In some browsers such as Firefox, <code>declaration()</code> will return <code>"first"</code>, and in other browsers like Chrome it'll return <code>"second"</code>, even though it looks like the <code>else</code> statement is never run.</p>

<p>If you want to know more about declarative functions, then you should read <a href="http://kangax.github.com/nfe/">Juriy Zaytsev's guide</a>, where he delves into the specifics. Suffice to say, they have fairly ambiguous behavior, and can lead to problems later down the road. All things considered, It's best to steer clear of them by using function expressions instead:</p>

<pre><code>var wem = function(){};
wem();
</code></pre>

<p>CoffeeScript's approach to this is to remove declarative functions entirely, using only function expressions.</p>

<h2>Number property lookups</h2>

<p>A flaw in JavaScript's parser means that the <em>dot notation</em> on numbers is interpreted as a floating point literal, rather than a property lookup. For example, the following JavaScript will cause a syntax error:</p>

<pre><code>5.toString();
</code></pre>

<p>JavaScript's parser is looking for another Number after the dot, and so raises an <code>Unexpected token</code> error when it encounters <code>toString()</code>. The solution to this is to either use parenthesis, or add an additional dot.</p>

<pre><code>(5).toString();
5..toString();
</code></pre>

<p>Fortunately CoffeeScript's parsers is clever enough to deal with this issue by using double dot notations automatically (as in the example above) whenever you access properties on Numbers.</p>

<h1>The un-fixed parts</h1>

<p>Whilst CoffeeScript goes some length to solving some of JavaScript's design flaws, it can only go so far. As I mentioned previously, CoffeeScript's strictly limited to static analysis by design, and doesn't do any runtime checking for performance reasons. CoffeeScript uses a straight source-to-source compiler, the idea being that every CoffeeScript statement results in a equivalent JavaScript statement. CoffeeScript doesn't provide an abstraction over any of JavaScript's keywords, such as <code>typeof</code>, and as such some design flaws in JavaScript's design also apply to CoffeeScript.</p>

<p>In the previous sections we covered some design flaws in JavaScript that CoffeeScript fixes. Now let's talk about some of JavaScript's flaws that CoffeeScript can't fix.</p>

<h2>Using eval</h2>

<p>Whilst CoffeeScript removes some of JavaScript's foibles, other features are a necessary evil, you just need to be aware of their shortcomings. A case in point, is the <code>eval()</code> function. Whilst undoubtedly it has its uses, you should know about its drawbacks, and avoid it if possible. The <code>eval()</code> function will execute a string of JavaScript code in the local scope, and functions like <code>setTimeout()</code> and <code>setInterval()</code> can also both take a string as their first argument to be evaluated.</p>

<p>However, like <code>with</code>, <code>eval()</code> throws the compiler off track, and is a major performance hog. As the compiler has no idea what's inside until runtime, it can't perform any optimizations like inlining. Another concern is with security. If you give it dirty input, <code>eval</code> can easily open up your code for injection attacks. 99% of the time when you're using <code>eval</code>, there are better &amp; safer alternatives (such as square brackets).</p>

<p><span class="csscript"></span></p>

<pre><code># Don't do this
model = eval(modelName)

# Use square brackets instead
model = window[modelName]
</code></pre>

<h2>Using typeof</h2>

<p>The <code>typeof</code> operator is probably the biggest design flaw of JavaScript, simply because it's basically completely broken. In fact, it really has only one use, checking to see if a value is <code>undefined</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>typeof undefinedVar is "undefined"
</code></pre>

<p>For all other types of type checking, <code>typeof</code> fails rather miserably, returning inconsistent results depending on the browser and how instances were instantiated. This isn't something that CoffeeScript can help you either, since the language uses static analysis and has no runtime type checking. You're on your own here.</p>

<p>To illustrate the problem, here's a table taken from <a href="http://bonsaiden.github.com/JavaScript-Garden/">JavaScript Garden</a> which shows some of the major inconstancies in the keyword's type checking.</p>

<pre><code>Value               Class      Type
-------------------------------------
"foo"               String     string
new String("foo")   String     object
1.2                 Number     number
new Number(1.2)     Number     object
true                Boolean    boolean
new Boolean(true)   Boolean    object
new Date()          Date       object
new Error()         Error      object
[1,2,3]             Array      object
new Array(1, 2, 3)  Array      object
new Function("")    Function   function
/abc/g              RegExp     object
new RegExp("meow")  RegExp     object
{}                  Object     object
new Object()        Object     object
</code></pre>

<p>As you can see, depending on if you define a string with quotes or with the <code>String</code> class affects the result of <code>typeof</code>. Logically <code>typeof</code> should return <code>"string"</code> for both checks, but for the latter it returns <code>"object"</code>. Unfortunately the inconstancies only get worse from there.</p>

<p>So what can we use for type checking in JavaScript? Well, luckily <code>Object.prototype.toString()</code> comes to the rescue here. If we invoke that function in the context of a particular object, it'll return the correct type. All we need to do is massage the string it returns, so we end up with the sort of string <code>typeof</code> should be returning. Here's an example implementation ported from jQuery's <code>$.type</code>:</p>

<p><span class="csscript"></span></p>

<pre><code>type = do -&gt;
  classToType = {}
  for name in "Boolean Number String Function Array Date RegExp Undefined Null".split(" ")
    classToType["[object " + name + "]"] = name.toLowerCase()

  (obj) -&gt;
    strType = Object::toString.call(obj)
    classToType[strType] or "object"

# Returns the sort of types we'd expect:
type("")         # "string"
type(new String) # "string"
type([])         # "array"
type(/\d/)       # "regexp"
type(new Date)   # "date"
type(true)       # "boolean"
type(null)       # "null"
type({})         # "object"
</code></pre>

<p>If you're checking to see if an variable has been defined, you'll still need to use <code>typeof</code> otherwise you'll get a <code>ReferenceError</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>if typeof aVar isnt "undefined"
  objectType = type(aVar)
</code></pre>

<p>Or more succinctly with the existential operator:</p>

<pre><code>objectType = type(aVar?)
</code></pre>

<p>As an alternative to type checking, you can often use duck typing and the CoffeeScript existential operator together to eliminating the need to resolve an object's type. For example, let's say we're pushing a value onto an array. We could say that, as long as the 'array like' object implements <code>push()</code>, we should treat it like an array:</p>

<p><span class="csscript"></span></p>

<pre><code>anArray?.push? aValue
</code></pre>

<p>If <code>anArray</code> is an object other than an array than the existential operator will ensure that <code>push()</code> is never called.</p>

<h2>Using instanceof</h2>

<p>JavaScript's <code>instanceof</code> keyword is nearly as broken as <code>typeof</code>. Ideally <code>instanceof</code> would compare the constructor of two object, returning a boolean if one was an instance of the other. However, in reality <code>instanceof</code> only works when comparing custom made objects. When it comes to comparing built-in types, it's as useless as <code>typeof</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>new String("foo") instanceof String # true
"foo" instanceof String             # false
</code></pre>

<p>Additionally, <code>instanceof</code> also doesn't work when comparing object from different frames in the browser. In fact, <code>instanceof</code> only returns a correct result for custom made objects, such as CoffeeScript classes.</p>

<p><span class="csscript"></span></p>

<pre><code>class Parent
class Child extends Parent

child = new Child
child instanceof Child  # true
child instanceof Parent # true
</code></pre>

<p>Make sure you only use it for your own objects or, even better, stick clear of it.</p>

<h2>Using delete</h2>

<p>The <code>delete</code> keyword can only safely be used for removing properties inside objects.</p>

<p><span class="csscript"></span></p>

<pre><code>anObject = {one: 1, two: 2}
delete anObject.one
anObject.hasOwnProperty("one") # false
</code></pre>

<p>Any other use, such as deleting variables or function's won't work.</p>

<p><span class="csscript"></span></p>

<pre><code>aVar = 1
delete aVar
typeof Var # "integer"
</code></pre>

<p>It's rather peculiar behavior, but there you have it. If you want to remove a reference to a variable, just assign it to <code>null</code> instead.</p>

<p><span class="csscript"></span></p>

<pre><code>aVar = 1
aVar = null
</code></pre>

<h2>Using parseInt</h2>

<p>JavaScript's <code>parseInt()</code> function can return unexpected results if you pass a string to it without informing it of the proper base. For example:</p>

<pre><code># Returns 8, not 10!
parseInt('010') is 8
</code></pre>

<p>Always pass a base to the function to make it work correctly:</p>

<pre><code># Use base 10 for the correct result
parseInt('010', 10) is 10
</code></pre>

<p>This isn't something CoffeeScript can do for you; you'll just have to remember to always specify a base when using <code>parseInt()</code>.</p>

<h2>Strict mode</h2>

<p>Strict mode is a new feature of ECMAScript 5 that allows you to run a JavaScript program or function in a <em>strict</em> context. This strict context throws more exceptions and warnings than the normal context, giving developers some indication when they're straying from best practices, writing un-optimizable code or making common mistakes. In other words, strict mode reduces bugs, increases security, improves performance and eliminates some difficult to use language features. What's not to like?</p>

<p>Strict mode is currently supported in the following browsers:</p>

<ul>
<li>Chrome >= 13.0</li>
<li>Safari >= 5.0</li>
<li>Opera >= 12.0</li>
<li>Firefox >= 4.0</li>
<li>IE >= 10.0</li>
</ul>


<p>Having said that, strict mode is completely backwards compatible with older browsers. Programs using it should run fine in either a strict or normal context.</p>

<h3>Strict mode changes</h3>

<p>Most of the changes strict mode introduces pertain to JavaScript's syntax:</p>

<ul>
<li>Errors on duplicate property and function argument names</li>
<li>Errors on incorrect use of the <code>delete</code> operator</li>
<li>Access to <code>arguments.caller</code> &amp; <code>arguments.callee</code> throws an error (for performance reasons)</li>
<li>Using the <code>with</code> operator will raise a syntax error</li>
<li>Certain variables such as <code>undefined</code> are no longer writeable</li>
<li>Introduces additional reserved keywords, such as <code>implements</code>, <code>interface</code>, <code>let</code>, <code>package</code>, <code>private</code>, <code>protected</code>, <code>public</code>, <code>static</code>, and <code>yield</code></li>
</ul>


<p>However, strict mode also changes some runtime behavior:</p>

<ul>
<li>Global variables are explicit (<code>var</code> always required). The global value of <code>this</code> is <code>undefined</code>.</li>
<li><code>eval</code> can't introduce new variables into the local context</li>
<li>Function statements have to be defined before they're used (previously functions could be <a href="http://whereswalden.com/2011/01/24/new-es5-strict-mode-requirement-function-statements-not-at-top-level-of-a-program-or-function-are-prohibited/">defined anywhere</a>).</li>
<li><code>arguments</code> is immutable</li>
</ul>


<p>CoffeeScript already abides by a lot of strict mode's requirements, such as always using <code>var</code> when defining variables, but it's still very useful to enable strict mode in your CoffeeScript programs. Indeed, CoffeeScript is taking this a step further and in <a href="https://github.com/jashkenas/coffee-script/issues/1547">future versions</a> will check a program's compliance to strict mode at compile time.</p>

<h3>Strict mode usage</h3>

<p>All you need to do to enable strict checking is start your script or function with the following string:</p>

<p><span class="csscript"></span></p>

<pre><code>-&gt;
  "use strict"

  # ... your code ...
</code></pre>

<p>That's it, just the <code>'use strict'</code> string. Couldn't be simpler and it's completely backwards compatible. Let's take a look at strict mode in action. The following function will raise a syntax error in strict mode, but run fine in the usual mode:</p>

<p><span class="csscript"></span></p>

<pre><code>do -&gt;
  "use strict"
  console.log(arguments.callee)
</code></pre>

<p>Strict mode has removed access to <code>arguments.caller</code> &amp; <code>arguments.callee</code> as they're major performance hogs, and is now throwing syntax errors whenever they're used.</p>

<p>There's a particular gotcha you should look out for when using strict mode, namely creating global variables with <code>this</code>. The following example will throw a <code>TypeError</code> in strict mode, but run fine in a normal context, creating a global variable:</p>

<p><span class="csscript"></span></p>

<pre><code>do -&gt;
  "use strict"
  class @Spine
</code></pre>

<p>The reason behind this disparity is that in strict mode <code>this</code> is <code>undefined</code>, whereas normally it refers to the <code>window</code> object. The solution to this is to explicitly set global variables on the <code>window</code> object.</p>

<p><span class="csscript"></span></p>

<pre><code>do -&gt;
  "use strict"
  class window.Spine
</code></pre>

<p>Whilst I recommend enabling strict mode, but it's worth noting that strict mode doesn't enable any new features that aren't ready possible in JavaScript, and will actually slow down your code a bit by having the VM do more checks at runtime. You may want to develop with strict mode, and deploy to production without it.</p>

<h2>JavaScript Lint</h2>

<p><a href="http://www.javascriptlint.com/">JavaScript Lint</a> is a JavaScript code quality tool, and running your programs through it is a great way of improving code quality and best practices. The project was based on a similar tool called <a href="http://www.jslint.com">JSLint</a>. Check out JSLint's site for a <a href="http://www.jslint.com/lint.html">great list</a> of issues that it checks for, including global variables, missing semicolons and weak equality comparisons.</p>

<p>The good news is that CoffeeScript already 'lints' all of its output, so CoffeeScript generated JavaScript is already JavaScript Lint compatible. In fact, the <code>coffee</code> tool has support for a <code>--lint</code> option:</p>

<pre><code>coffee --lint index.coffee
  index.coffee: 0 error(s), 0 warning(s)
</code></pre>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - 编译</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 返回目录</a></div>


<h1>CoffeeScript的自动编译</h1>

<p>使用CoffeeScript的一个问题是，它会在你和JavaScript之间多加了一个层，当CoffeeScript文件频繁变更时你还需要手工编译它们。</p>

<p>如第一章所说，我们可以使用<code>coffee</code>命令来编译CoffeeScript文件：</p>

<pre><code>coffee --compile --output lib src
</code></pre>

<p>在上面的例子中，事实上，在<code>src</code>中的<code>.coffee</code>文件会被编译为JavaScript并且输出到<code>lib</code>目录中。这样编译看起来有点无聊，因此让我们看一下如何自动地编译。</p>

<h2>Cake</h2>

<p><a href="http://jashkenas.github.com/coffee-script/#cake">Cake</a>是一个超级简单的与 <a href="http://www.gnu.org/software/make/">Make</a>和 <a href="http://rake.rubyforge.org/">Rake</a>类似的构建工具。该库被捆绑在<code>coffee-script</code>的npm安装包中，可以通过名为<code>cake</code>的可执行程序来使用。</p>

<p>你可以使用在一个名为<code>Cakefile</code>的文件中使用CoffeeScript来定义任务。Cake可以去读它，而且可以在当前目录中通过运行<code>cake[task][options]</code>来调用它。单单输入<code>cake</code>可以显示一个任务项以及参数的列表。</p>

<p>可以使用<code>task()</code>函数来定义任务项，给它传递一个名字、参数以及回调函数即可。例如，创建一个名为<code>Cakefile</code>的文件，还有两个目录——<code>lib</code>和<code>src</code>。把下面的代码添加到Cake文件中；</p>

<p><span class="csscript"></span></p>

<pre><code>fs = require 'fs'

{print} = require 'sys'
{spawn} = require 'child_process'

build = (callback) -&gt;
  coffee = spawn 'coffee', ['-c', '-o', 'lib', 'src']
  coffee.stderr.on 'data', (data) -&gt;
    process.stderr.write data.toString()
  coffee.stdout.on 'data', (data) -&gt;
    print data.toString()
  coffee.on 'exit', (code) -&gt;
    callback?() if code is 0

task 'build', 'Build lib/ from src/', -&gt;
  build()
</code></pre>

<p>在上面的例子中，我们定义了一个名为<code>build</code>的任务项，该任务项可以通过运行<code>cake build</code>来调用。这运行的是与之前例子一样的命令。将<code>src</code>内的CoffeeScript文件编译为JavaScript放到<code>lib</code>中。你现在可以如往常一样在HTML中引用<code>lib</code>中的JavaScript文件了。</p>

<p><span class="csscript"></span></p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=utf-8&gt;
&lt;script src="lib/app.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;      
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>我们在CoffeeScript代码变了之后还需要手动的运行<code>cake build</code>命令，这很不理想。幸运的是，<code>coffee</code>命令接受另外一个<code>--watch</code>参数，指示它监视一个目录的变化并且按需重新编译。让我们用它来定义另外一个任务项：</p>

<p><span class="csscript"></span></p>

<pre><code> task 'watch', 'Watch src/ for changes', -&gt;
    coffee = spawn 'coffee', ['-w', '-c', '-o', 'lib', 'src']
    coffee.stderr.on 'data', (data) -&gt;
      process.stderr.write data.toString()
    coffee.stdout.on 'data', (data) -&gt;
      print data.toString()
</code></pre>

<p>如果一个任务项依赖了另一个，你是使用<code>invoke(name)</code>来运行其他任务项。让我添加一个实用懂得任务项到我们的<code>Cakefile</code>中，该任务首先打开<code>index.html</code>然后就开始监视源文件的改变了。</p>

<p><span class="csscript"></span></p>

<pre><code>task 'open', 'Open index.html', -&gt;
  # First open, then watch
  spawn 'open', 'index.html'
  invoke 'watch'
</code></pre>

<p>你可以使用<code>option()</code>函数来给你的任务项定义参数，它接受一个短名、长名和描述三个参数。</p>

<p><span class="csscript"></span></p>

<pre><code>option '-o', '--output [DIR]', 'output dir'

task 'build', 'Build lib/ from src/', -&gt;
  # Now we have access to a `options` object
  coffee = spawn 'coffee', ['-c', '-o', options.output or 'lib', 'src']
  coffee.stderr.on 'data', (data) -&gt;
    process.stderr.write data.toString()
  coffee.stdout.on 'data', (data) -&gt;
    print data.toString()
</code></pre>

<p>如汝所见，任务项上下文可获一包含用户指定的所有参数的<code>options</code>对象。如若我等执行<code>cake</code>之令而不带任何参数，则所有任务项与参数列之。</p>

<p>Cake是一种自动化常见任务项（例如编译CoffeeScript）的有效的方式，避免了bash或者Makefiles的麻烦。 <a href="http://jashkenas.github.com/coffee-script/documentation/docs/cake.html">Cake的源码</a>也值得一看，上面不但展示了CoffeeScript强大的表现力，旁边还有一份漂亮的由代码注释生成的文档。</p>

<h2>Server端的支持</h2>

<p>对于静态的站点来说使用Cake就已经足够，但是对于动态的站点来说，我们就需要把CoffeeScript集成到请求/回应的生命周期中，对于那些比较流行的后端语言或者开发框架（例如<a href="http://rubyonrails.org/">Rails</a>和<a href="https://www.djangoproject.com/">Django</a>）来说已经存在各种各样的集成方案了。</p>

<p>Rails 3.1通过<a href="https://github.com/sstephenson/sprockets">Sprockets &amp; the asset pipeline</a>实现了对CoffeeScript的支持。把你的CoffeeScript放到<code>app/assets/javascripts</code>中，Rails就能够智能地按照请求需要对其进行预编译。可以使用特殊的注释来指示联合和打包JavaScript和CoffeeScript文件，这就意味着你可以通过一次请求获取程序的全部JavaScript。当发布到生成环境时，Rails会把编译后的文件输出出来，以保证能够缓存文件快速提供服务。</p>

<p>Rack服务器是其他可选方案之一，比如说37signal的<a href="http://pow.cx/">Pow</a> 和Joshua Peek的<a href="http://josh.github.com/nack/">Nack</a>都是。如果你的程序不需要Rails其他特性或者相关东西的话我力荐你使用它们，</p>

<p>Django通过特殊的模板标签也能<a href="http://pypi.python.org/pypi/django-coffeescript/">支持CoffeeScript</a>。而且同时支持行内代码或者外联文件。</p>

<p>当需要编译CoffeeScript时，Ruby和Python在后台都是通过管道将其输出到Node和CoffeeScript库中，因此你在开发时需要事先安装好这些类库。如果你直接使用Node为你的站点开发后端程序，就非常容易集成CoffeeScript了，而且你还可以同时使用它来开发的前后台的代码。我们将在下一章介绍更多相关的东西，使用<a href="https://github.com/sstephenson/stitch">Stitch</a>来为我们的客户端CoffeeScript提供服务。</p>

  </div>
</div>
</body>
</html>