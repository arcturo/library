<div class="back"><a href="index.html">&laquo; Back to all chapters</a></div>

#Creating Applications
#创建应用程序

Now you've been given an overview of the syntax, lets explore actually structuring and creating CoffeeScript applications. This section aims to be useful to all CoffeeScript developers, novice or advanced. Indeed, it should be relevant to pure JavaScript developers too. 
既然你基本已经了解了CoffeeScript的语法，那现在让我们来探索下如何使用它来真枪实弹的创建应用程序。本节内容对所有的CoffeeScript开发者都有用，无论你是新人还是老手，实际上，这对只写JavaScript的人来说也非常有用。

For some reason, when developers are building client side JavaScript applications, tried and tested patterns and conventions often fly out the window, and the end result is a spaghetti mess of un-maintainable coupled JavaScript. I can't stress enough how important application architecture is; if you're writing any JavaScript/CoffeeScript beyond simple form validation you should implement a form of application structure, such as [MVC](http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller). 
不知什么原因，当开发者构建JavaScript客户端程序时，往往不会使用可靠的测试过的模式或约定，这就导致大量的代码像意大利面条一样无法维护。程序架构的重要性再怎么强调都不过分。如果你所写的JavaScript或者CoffeeScript不是表单验证这么简单的话，你需要使用某种程序架构，比方说[MVC](http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller)。

The secret to building maintainable large applications is not to build large applications. In other words, build a series of modular de-coupled components. Keep application logic as generic as possible, abstracting it out as appropriate. Lastly separate out your logic into views, models and controllers (MVC). Implementing MVC is beyond the scope of this chapter, for that I recommend you check out my book on [JavaScript Web Applications](http://oreilly.com/catalog/9781449307530/) and use a framework like [Backbone](http://documentcloud.github.com/backbone/) or [Spine](https://github.com/maccman/spine). Rather than that, here we're going to cover structuring applications using CommonJS modules.
创建可维护的大型应用程序的秘诀就是不要做大型程序。换句话说，就是创建一系列低耦和的模块。程序逻辑越通用越好，尽量抽象出来。最终，将你的逻辑分别拆分为视图（views）、数据模型（models）和控制器（controllers）（MVC）。如何实现MVC超出了本章的范围，需要的话我建议你到[JavaScript Web Applications](http://oreilly.com/catalog/9781449307530/)翻看我的书，或者使用像[Backbone](http://documentcloud.github.com/backbone/) 或者 [Spine](https://github.com/maccman/spine)这类框架。现在先不管那些，在这里我们使用CommonJS模块来构建应用程序。

##Structure & CommonJS
## 结构 & CommonJS

So what exactly are CommonJS modules? Well, If you've used [NodeJS](http://nodejs.org/) before you've used CommonJS modules, probably without realizing it. CommonJS modules were initially developed for writing server side JavaScript libraries, in an attempt to deal with loading, namespacing and scoping issues. They were a common format that would be compatible across all JavaScript implementations. The aim was that a library written for [Rhino](http://www.mozilla.org/rhino/) would work for Node. Eventually these ideas transitioned back to browsers, and now we have great libraries like [RequireJS](http://requirejs.org) and [Yabble](https://github.com/jbrantly/yabble) to use modules client-side. 
那什么CommonJS模块到底是什么呢？好的，如果你用过[NodeJS](http://nodejs.org/) 的话，你大概没有意识到你在使用CommonJS模块。CommonJS模块起初是为了编写服务器端JavaScript类库而开发的，企图用它来解决模块加载、命名空间和作用域的问题。还有一个通用的形式用来兼容所有的JavaScript实现。目标是写一个给[Rhino](http://www.mozilla.org/rhino/) 的类库也可以用于Node。终于这种思想被移植到了浏览器中，而且现在我们有像[RequireJS](http://requirejs.org)和[Yabble](https://github.com/jbrantly/yabble)这样好的类库来构建模块化的客户端。

Practically speaking, modules ensure that your code is run in a local namespace (code encapsulation), that you can load other modules with the `require()` function, and expose module properties via `module.exports`. Let's dive into that in a bit more depth now. 
实际上，模块能保证你的代码运行在局部作用域中（代码分装），你可以通过`require()`函数来载入模块，而且通过`module.exports`来暴露模块。让我们更加深入的研究下。

###Requiring files
###导入文件

You can load in other modules and libraries using `require()`. Simply pass a module name and, if it's in the load path, it'll return an object representing that module. For example:
你可是使用`require()`来载入其他模块和类库。只给它传递一个模块名即可，而且如果该模块正加载目录中，`require()`会返回一个代表该模块的对象。例如：

    User = require("models/user")
    
Synchronous require support is a contentious issue, but has mostly been resolved with the mainstream loader libraries and latest CommonJS [proposals](http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition). It may be something you'll have to look into if you decided to take a separate route than the one I'm advocating with Stitch below. 
同步的`require`是一个颇具争议的问题，但是主流的类库加载器和CommonJS的预案中已经解决了这个问题。如果你不想使用我下面推荐的Stitch而想另走一条路的话，你可能需要看一下它。

###Exporting properties
###暴露属性

By default, modules don't expose any properties so their contents are completely invisible to `require()` calls. If you want a particular property to be accessible from your module, you'll need to set it on `module.exports`:
默认情况下，模块不会暴露任何属性，因此模块内的东西对于`require()`调用来说不可见。如果你想访问模块的某个属性，你需要将它挂到`module.exports`：

    # random_module.js
    module.exports.myFineProperty = ->
      # Some shizzle
    
Now, whenever this module is required then `myFineProperty` will be exposed:
现在，`require`这个模块的时候`myFineProperty`就会暴露出来：

    myFineProperty = require("random_module").myFineProperty

##Stitch it up
##使用Stitch打包

Formatting your code as CommonJS modules is all fine and dandy, but how do you actually get this working on the client in practice? Well, my method of choice is the rather unheard of [Stitch](https://github.com/sstephenson/stitch) library. Stitch is by Sam Stephenson, the mind behind [Prototype.js](http://www.prototypejs.org) amongst other things, and solves the module problem so elegantly it makes me want to dance for joy! Rather than try and dynamically resolve dependencies, Stitch simply bundles up all your JavaScript files into one, wrapping them in some CommonJS magic. Oh, and did I mention it'll compile your CoffeeScript, JS templates, [LESS CSS](http://lesscss.org) and [Sass](http://sass-lang.com) files too!
把你的代码格式化为CommnonJS模块很不错，但是如何让这些模块在客户端也能工作呢？我采用[Stitch](https://github.com/sstephenson/stitch)这个不太有名的类库作为解决方案。Stitch的作者是Sam Stephenson，其思想来自于[Prototype.js](http://www.prototypejs.org)，非常优雅的解决了模块的问题，真让我兴奋呀！Stitch简单将所有的JavaScript文件打包到一起，巧妙的将它们包裹在CommonJS中，而不是尝试动态处理依赖。噢，我差点忘记说 ，它还能编译CoffeeScript、JS模板、[LESS CSS](http://lesscss.org)和[Sass](http://sass-lang.com)。 

First things first, you'll need to install [Node.js](http://nodejs.org/) and [npm](http://npmjs.org/) if you haven't already, we'll be using those throughout this chapter.
首先，如果你必须安装 [Node.js](http://nodejs.org/)和[npm](http://npmjs.org/)，如果还没有安装的话。在本章中我们要用到它们。
    
Now let's create our application structure. If you're using [Spine](https://github.com/maccman/spine), you can automate this with [Spine.App](http://github.com/maccman/spine.app), otherwise it's something you'll need to do manually. I usually have an `app` folder for all the application specific code, and a `lib` folder for general libraries. Then anything else, including static assets, goes in the `public` directory.
现在，创建我们的程序结构。如果你正在使用[Spine](https://github.com/maccman/spine)，那你可以使用[Spine.App](http://github.com/maccman/spine.app)自动生成，否则你需要手动的创建。我通常把全部的程序代码放到`app`目录下，`lib`存放通常的类库，然后包括其他一些像静态资源等等放到`public`目录中。

    app
    app/controllers
    app/views
    app/models
    app/lib
    lib
    public
    public/index.html

Now to actually boot up the Stitch server. Let's create a file called `index.coffee` and fill it with the following script:
接着，为了启动我们的Stitch服务，让我们创建一个名为`index.coffee`的文件，添加如下脚本：

<span class="csscript"></span>

    require("coffee-script")
    stitch  = require("stitch")
    express = require("express")
    argv    = process.argv.slice(2)
    
    package = stitch.createPackage(
      # Specify the paths you want Stitch to automatically bundle up
      paths: [ __dirname + "/app" ]
      
      # Specify your base libraries
      dependencies: [
        # __dirname + '/lib/jquery.js'
      ]
    )
    app = express.createServer()
    
    app.configure ->
      app.set "views", __dirname + "/views"
      app.use app.router
      app.use express.static(__dirname + "/public")
      app.get "/application.js", package.createServer()

    port = argv[0] or process.env.PORT or 9294
    console.log "Starting server on port: #{port}"
    app.listen port
    
You can see some dependencies listed: `coffee-script`, `stitch` and `express`. We need to create a `package.json` file, listing these dependencies so npm can pick them up. Our `./package.json` file will look like this:
你会发现我们依赖了一些类库：`coffee-scirpt`、`stitch`和`express`。我们需要创建一个`package.json`文件，列出这些依赖类库以便npm可以将它们打包到一起。我们的`./package.json`看起来像下面这样：

    {
      "name": "app",
      "version": "0.0.1",
      "dependencies": { 
        "coffee-script": "~1.1.2",
        "stitch": "~0.3.2",
        "express": "~2.5.0",
        "eco": "1.1.0-rc-1"
      }
    }
    
And let's install those dependencies with npm:
然后让我使用npm安装这些依赖：

    npm install .
    npm install -g coffee-script
    
Rightio, we're almost there. Now run: 
好，我们就要完成了，现在运行：

    coffee index.coffee
    
You'll hopefully have a Stitch server up and running. Let's go ahead and test it out by putting an `app.coffee` script in the `app` folder. This will be the file that'll bootstrap our application.
但愿你的stitch服务器已经运行起来了，让我继续在`app`目录中添加一个`app.coffee`脚本来测试下。这个就是将要引导启动我们程序的文件。

<span class="csscript"></span>

    module.exports = App =
      init: ->
        # Bootstrap the app
        
Now let's create our main page `index.html` which, if we're building a single page app, will be the only page the user actually navigates to. This is a static asset, so it's located under the `public` directory.
现在让我们创建主页`index.html`，如果我们创建的是单页面程序，那它将是唯一一个我们会访问的页面。这是一个静态资源，因此将其放在`public`目录下。
  
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset=utf-8>
      <title>Application</title>
      <!-- Require the main Stitch file -->
      <script src="/application.js" type="text/javascript" charset="utf-8"></script>
      <script type="text/javascript" charset="utf-8">
        document.addEventListener("DOMContentLoaded", function(){
          var App = require("app");
          App.init();
        }, false);
      </script>
    </head>
    <body>
    </body>
    </html>

When the page loads, our *DOMContentLoaded* event callback is requiring the `app.coffee` script (which is automatically compiled), and invoking our `init()` function. That's all there is to it, we've got CommonJS modules up and running, as well as a HTTP server and CoffeeScript compiler. If, say, we wanted to include a module, it's just a case of calling `require()`. Let's create a new class, `User`, and reference it from `app.coffee`:
当页面加载完成，我们的*DOMContentLoaded*事件回调函数会require`app.coffee`脚本（它已经被自动编译好了），然后调用`init()`函数。其实就是这样，我们获取了一个CommonJS模块并且运行了它，就如一个HTTP服务器和CoffeeScript编译器一样。假如，我们想包含一个模块，只需调用`require()`即可。让我们创建一个新的类，`User`，在`app.coffee`中引用它：

<span class="csscript"></span>

    # app/models/user.coffee
    module.exports = class User
      constructor: (@name) ->
      
    # app/app.coffee
    User = require("models/user")

##JavaScript templates
##JavaScript模板

If you're moving logic to the client side, then you'll definitely need some sort of templating library. JavaScript templating is very similar to templates on the server, such as Ruby's ERB or Python's text interpolation, expect of course it runs client side. There are a whole host of templating libraries out there, so I encourage you to do some research and check them out. By default, Stitch comes with support for [Eco](https://github.com/sstephenson/eco) templates baked right in. 
如果你把逻辑都放到了客户端，那你就必须使用某种模板引擎。JavaScript模板除了它运行在客户端之外,与服务器端的模板引擎非常相似，比方说Ruby的ERB或者Python的文本插值。有很多模板类库，因此我鼓励你进行研究将它们找出来。默认地，Stitch预置了对[Eco](https://github.com/sstephenson/eco)的支持。

JavaScript templates are very similar to server side ones. You have template tags interoperated with HTML, and during rendering those tags get evaluated and replaced. The great thing about [Eco](https://github.com/sstephenson/eco) templates, is they're actually written in CoffeeScript. 
JavaScript模板与服务端模板非常相似。你可以混合使用模板标签和HTML，在模板绘制过程中这些标签会被求值被替换。[Eco](https://github.com/sstephenson/eco)模板最好的地方在于，它们可以直接使用CoffeeScript。

Here's an example:
例如：

    <% if @projects.length: %>
      <% for project in @projects: %>
        <a href="<%= project.url %>"><%= project.name %></a>
        <p><%= project.description %></p>
      <% end %>
    <% else: %>
      No projects
    <% end %>

As you can see, the syntax is remarkably straightforward. Just use `<%` tags for evaluating expressions, and `<%=` tags for printing them. A partial list of template tags is as follows:
如你所见，模板语法非常明了。只需使用`<%`标签来执行表达式，`<%=`标签输出表达式的值。下面是一个部分模板标签的列表：
    
* `<% expression %>`  
  Evaluate a CoffeeScript expression without printing its return value.
  对一个CoffeeScript表达式求值，但不输出其返回值

* `<%= expression %>`  
  Evaluate a CoffeeScript expression, escape its return value, and print it.
  对一个CoffeeScript表达式求值，转义返回值，并将其输出。

* `<%- expression %>`  
  Evaluate a CoffeeScript expression and print its return value without escaping it.
  对一个CoffeeScript表达式求值，不转义，直接输出返回值。

You can use any CoffeeScript expression inside the templating tags, but there's one thing to look out for. CoffeeScript is whitespace-sensitive, but your Eco templates aren't. Therefore, Eco template tags that begin an indented CoffeeScript block must be suffixed with a colon. To indicate the end of an indented block, use the special tag `<% end %>`. For example:
你可以在模板标签中使用任意的CoffeeScript表达式，但是有一点需要注意，就是虽然CoffeeScript对空格敏感，但是Eco模板不敏感。因此，Eco模板标签在开始一个CoffeeScirpt缩进块时必须使用一个冒号作为后缀。然后使用一个特殊的标签`<% end %>`来表示缩进块结束。例如：

    <% if @project.isOnHold(): %>
      On Hold
    <% end %>
    
You don't need to write the `if` and `end` tags on separate lines:
`if`和`end`并非要写成多行：

    <% if @project.isOnHold(): %> On Hold <% end %>

And you can use the single-line postfix form of `if` as you'd expect:
而且你也可以使用`if`单行后缀表达式来实现：

    <%= "On Hold" if @project.isOnHold() %>

Now we've got a handle on the syntax, let's define an Eco template in `views/users/show.eco`:
现在我们已经学习了语法，让我们在`views/users/show.eco`定义一个Eco模板吧：
    
    <label>Name: <%= @name %></label>
    
Stitch will automatically compile our template and include it in `application.js`. Then, in our application's controllers we can require the template, like it was a module, and execute it passing any data required.
Stitch会自动编译我们的模板且把它们打包到`application.js`中。然后，在程序控制器中我们就可以require模板，就像使用一个模块一样，传入所以的数据执行它。 
    
<span class="csscript"></span>

    require("views/users/show")(new User("Brian"))
    
Our `app.coffee` file should now look like this, rendering the template and appending it to the page when the document loads:
我们的`app.coffee`文件现在看起来像下面这样，当文档加载完毕后，我们渲染这个模板并将其添加到页面中：

<span class="csscript"></span>

    User = require("models/user")

    App =
      init: ->
        template = require("views/users/show")
        view     = template(new User("Brian"))

        # Obviously this could be spruced up by jQuery
        element = document.createElement("div")
        element.innerHTML = view
        document.body.appendChild(element)
    
    module.exports = App
    
Open up [the application](http://localhost:9294/) and give it a whirl! Hopefully this tutorial has given you a good idea of how to structure client-side CoffeeScript applications. For your next steps, I recommend checking out a client-side framework like [Backbone](http://documentcloud.github.com/backbone/) or [Spine](http://spinejs.com), They'll provide a basic MVC structure for you, freeing you up for the interesting stuff.
访问[http://localhost:9294/](http://localhost:9294/)，然后随便到处转转！希望这个教程能够教会你如何构建一个客户端的CoffeeScript程序。下一步，我推荐研究一些客户端模块，比方说[Backbone](http://documentcloud.github.com/backbone/)或者[Spine](http://spinejs.com)，它们能够为你提供一个基础的MVC框架，将你解放出来，做你感兴趣的事情。
    
##Bonus - 30 second deployment with Heroku
##附加-使用Heroku 30秒快速发布

[Heroku](http://heroku.com/) is an incredibly awesome web host that manages all the servers and scaling for you, letting you get on with the exciting stuff (building awesome JavaScript applications). You'll need an account with Heroku for this tutorial to work, but the great news is that their basic plan is completely free. While traditionally a Ruby host, Heroku have recently released their Cedar stack, which includes Node support. 
[Heroku](http://heroku.com/)是一个非常棒的Web主机服务提供商。它为你管理所有的服务器和扩展，让你能够做自己感兴趣的事情（创建有意思的JavaScript程序）。要让本教程的实例工作你需要一个Heroku账户，好消息是它基本套餐是免费的。之前Heroku提供的是Ruby主机服务，不过现在最近它发布了它的Cedar栈，支持Node。

Firstly we need to make a `Procfile`, which will inform Heroku about our application.
首先，我们需要创建一个`Profile`文件，用它来向Heroku提供我们的程序信息。

    echo "web: coffee index.coffee" > Procfile

Now, if you haven't already, you'll need to create a local git repository for your application. 
然后，你需要为你的程序创建一个本地的git代码仓库，如果你还没有创建的话。

    git init
    git add .
    git commit -m "First commit"    
    
And now to deploy the application, we'll use the `heroku` gem (which you'll need to install if you haven't already).
现在发布程序，我们将使用`heroku`这个gem（如果你还没安装的话，你需要先安装好）。

    heroku create myAppName --stack cedar
    git push heroku master
    heroku open
    
That's it! Seriously, that's all there is to it. Hosting Node applications has never been easier.
好了，这样做就行了。没有比这还简单的Node主机的服务了。

##Additional libraries
##其他类库

[Stitch](https://github.com/sstephenson/stitch) and [Eco](https://github.com/sstephenson/eco) aren't the only libraries you can use for creating CoffeeScript & Node applications, there are a variety of alternatives.
[Stitch](https://github.com/sstephenson/stitch)和[Eco](https://github.com/sstephenson/eco)并不是唯一你可用于创建CoffeeScript和Node程序的类库，还有很多可作为替代的类库。

For example, when it comes to templating, you can use [Mustache](http://mustache.github.com), [Jade](http://jade-lang.com) or write your HTML in pure CoffeeScript using [CoffeeKup](http://coffeekup.org).
例如，当需要使用模板时，你可以使用 [Mustache](http://mustache.github.com)、[Jade](http://jade-lang.com)或者[CoffeeKup](http://coffeekup.org)（使用纯CoffeeScript写HTML）。

As for serving up application, [Hem](http://github.com/maccman/hem) is a great choice, supporting both CommonJS and NPM modules and integrating seamlessly with the CoffeeScript MVC framework [Spine](http://spinejs.com). [node-browsify](https://github.com/substack/node-browserify) is another similar project. Or if you want to go lower level with [express](http://expressjs.com/) integration, there's Trevor Burnham's [connect-assets](https://github.com/TrevorBurnham/connect-assets)
说到为程序提供服务，[Hem](http://github.com/maccman/hem)是比较好的选择，支持CommonJS和NPM模块，而且还无缝的集成了CoffeeScript MVC框架[Spine](http://spinejs.com)。[node-browsify](https://github.com/substack/node-browserify)是另外一个类似的项目。如果你想使用[express](http://expressjs.com/)集成的更底层的东西，Trevor Burnham的[connect-assets](https://github.com/TrevorBurnham/connect-assets)不错。

You can find a full list of CoffeeScript web framework plugins, on the [project's wiki](https://github.com/jashkenas/coffee-script/wiki/Web-framework-plugins).
你可以在[项目的wiki](https://github.com/jashkenas/coffee-script/wiki/Web-framework-plugins)上找到一个CoffeeScript Web框架插件的完整列表。
