#Automating CoffeeScript compilation
#CoffeeScript的自动编译

An issue with CoffeeScript is that it puts another layer between you and JavaScript, and having to manually compile CoffeeScript files whenever they change quickly gets old. Fortunately CoffeeScript has some alternative forms of compilation which can make the development cycle somewhat smoother.

使用CoffeeScript的一个问题是，它会在你和JavaScript之间多加了一个层，当CoffeeScript文件频繁变更时你还需要手工编译它们。

As we covered in the first chapter, we can compile CoffeeScript files using the `coffee` executable:

如第一章所说，我们可以使用`coffee`命令来编译CoffeeScript文件：
    
    coffee --compile --output lib src
    
In fact in the example above, all the `.coffee` files in `src` will be compiled & their JavaScript outputted to the `lib` directory. Even calling that is a bit of a bore, so let's look into automating it.

在上面的例子中，事实上，在`src`中的`.coffee`文件会被编译为JavaScript并且输出到`lib`目录中。这样编译看起来有点无聊，因此让我们看一下如何自动地编译。

##Cake
##Cake

[Cake](http://jashkenas.github.com/coffee-script/#cake) is a super simple build system along the lines of [Make](http://www.gnu.org/software/make/) and [Rake](http://rake.rubyforge.org/). The library is bundled with the `coffee-script` npm package, and available via an executable called `cake`.

[Cake](http://jashkenas.github.com/coffee-script/#cake)是一个超级简单的与 [Make](http://www.gnu.org/software/make/)和 [Rake](http://rake.rubyforge.org/)类似的构建工具。该库被捆绑在`coffee-script`的npm安装包中，可以通过名为`cake`的可执行程序来使用。

You can define tasks using CoffeeScript in a file called `Cakefile`. Cake will pick these up, and can be invoked by running `cake [task] [options]` from within the directory. To print a list of all the tasks and options, just type `cake`.

你可以使用在一个名为`Cakefile`的文件中使用CoffeeScript来定义任务。Cake可以去读它，而且可以在当前目录中通过运行`cake[task][options]`来调用它。单单输入`cake`可以显示一个任务项以及参数的列表。

Tasks are defined using the `task()` function, passing a name, optional description and callback function. For example, create a file called `Cakefile`, and two directories, `lib` and `src`. Add the following to the `Cakefile`:

可以使用`task()`函数来定义任务项，给它传递一个名字、参数以及回调函数即可。例如，创建一个名为`Cakefile`的文件，还有两个目录——`lib`和`src`。把下面的代码添加到Cake文件中；

<span class="csscript"></span>

    fs = require 'fs'

    {print} = require 'sys'
    {spawn} = require 'child_process'

    build = (callback) ->
      coffee = spawn 'coffee', ['-c', '-o', 'lib', 'src']
      coffee.stderr.on 'data', (data) ->
        process.stderr.write data.toString()
      coffee.stdout.on 'data', (data) ->
        print data.toString()
      coffee.on 'exit', (code) ->
        callback?() if code is 0
    
    task 'build', 'Build lib/ from src/', ->
      build()
      
In the example above, we're defining a task called `build` that can be invoked by running: `cake build`. This runs the same command as the previous example, compiling all the CoffeeScript files in `src` to JavaScript in `lib`. You can now reference JavaScript files in the `lib` directory as per usual from your HTML:

在上面的例子中，我们定义了一个名为`build`的任务项，该任务项可以通过运行`cake build`来调用。这运行的是与之前例子一样的命令。将`src`内的CoffeeScript文件编译为JavaScript放到`lib`中。你现在可以如往常一样在HTML中引用`lib`中的JavaScript文件了。

<span class="csscript"></span>

    <!DOCTYPE html>
    <html>
    <head>
    <meta charset=utf-8>
    <script src="lib/app.js" type="text/javascript" charset="utf-8"></script>      
    </head>
    <body>
    </body>
    </html>

We're still having to manually run `cake build` whenever our CoffeeScript code changes, which is far from ideal. Luckily, the `coffee` command takes another option, `--watch`, which instructs it to watch a directory for changes and re-compiling as necessary. Let's define another task using that:

我们在CoffeeScript代码变了之后还需要手动的运行`cake build`命令，这很不理想。幸运的是，`coffee`命令接受另外一个`--watch`参数，指示它监视一个目录的变化并且按需重新编译。让我们用它来定义另外一个任务项：

<span class="csscript"></span>

     task 'watch', 'Watch src/ for changes', ->
        coffee = spawn 'coffee', ['-w', '-c', '-o', 'lib', 'src']
        coffee.stderr.on 'data', (data) ->
          process.stderr.write data.toString()
        coffee.stdout.on 'data', (data) ->
          print data.toString()

If one task relies on another, you can run other tasks using `invoke(name)`. Let's add a utility task to our `Cakefile` which is going to both open  `index.html` and start watching the source for changes.

如果一个任务项依赖了另一个，你是使用`invoke(name)`来运行其他任务项。让我添加一个实用懂得任务项到我们的`Cakefile`中，该任务首先打开`index.html`然后就开始监视源文件的改变了。

<span class="csscript"></span>

    task 'open', 'Open index.html', ->
      # First open, then watch
      spawn 'open', 'index.html'
      invoke 'watch'

You can also define options for your task using the `option()` function, which takes a short name, long name and description.

你可以使用`option()`函数来给你的任务项定义参数，它接受一个短名、长名和描述三个参数。

<span class="csscript"></span>

    option '-o', '--output [DIR]', 'output dir'

    task 'build', 'Build lib/ from src/', ->
      # Now we have access to a `options` object
      coffee = spawn 'coffee', ['-c', '-o', options.output or 'lib', 'src']
      coffee.stderr.on 'data', (data) ->
        process.stderr.write data.toString()
      coffee.stdout.on 'data', (data) ->
        print data.toString()

As you can see, the task context now has access to an `options` object containing any data specified by the user. If we run `cake` without any other arguments, all the tasks and options will be listed.

如汝所见，任务项上下文可获一包含用户指定的所有参数的`options`对象。如若我等执行`cake`之令而不带任何参数，则所有任务项与参数列之。

Cake's a great way of automating common tasks such as compiling CoffeeScript without going to the hassle of using bash or Makefiles. It's also worth taking a look at [Cake's source](http://jashkenas.github.com/coffee-script/documentation/docs/cake.html), a great example of CoffeeScript's expressiveness and beautifully documented alongside the code comments.

Cake是一种自动化常见任务项（例如编译CoffeeScript）的有效的方式，避免了bash或者Makefiles的麻烦。 [Cake的源码](http://jashkenas.github.com/coffee-script/documentation/docs/cake.html)也值得一看，上面不但展示了CoffeeScript强大的表现力，旁边还有一份漂亮的由代码注释生成的文档。

##Server side support
##Server端的支持

Using Cake for CoffeeScript compilation is fine for static sites, but for dynamic sites we might as well integrate CoffeeScript compilation into the request/response cycle. Various integration solutions already exist for the popular backend languages and frameworks, such as [Rails](http://rubyonrails.org/) and [Django](https://www.djangoproject.com/). 

对于静态的站点来说使用Cake就已经足够，但是对于动态的站点来说，我们就需要把CoffeeScript集成到请求/回应的生命周期中，对于那些比较流行的后端语言或者开发框架（例如[Rails](http://rubyonrails.org/)和[Django](https://www.djangoproject.com/)）来说已经存在各种各样的集成方案了。

When it comes to Rails 3.1, CoffeeScript support comes via [Sprockets & the asset pipeline](https://github.com/sstephenson/sprockets). Add your CoffeeScript files under `app/assets/javascripts`, and Rails is smart enough to pre-compile them when they're requested. JavaScript & CoffeeScript files are concatenated and bundled using special comment directives, meaning you can fetch all of your application's JavaScript with one request. When it comes to production, Rails will write the compiled output to disk, ensuring it's cached and fast to serve. 

Rails 3.1通过[Sprockets & the asset pipeline](https://github.com/sstephenson/sprockets)实现了对CoffeeScript的支持。把你的CoffeeScript放到`app/assets/javascripts`中，Rails就能够智能地按照请求需要对其进行预编译。可以使用特殊的注释来指示联合和打包JavaScript和CoffeeScript文件，这就意味着你可以通过一次请求获取程序的全部JavaScript。当发布到生成环境时，Rails会把编译后的文件输出出来，以保证能够缓存文件快速提供服务。

Other Ruby options include Rack servers such as 37signal's [Pow](http://pow.cx/) and Joshua Peek's [Nack](http://josh.github.com/nack/), both highly recommended if your application doesn't need Rail's other features and associated overhead.

Rack服务器是其他可选方案之一，比如说37signal的[Pow](http://pow.cx/) 和Joshua Peek的[Nack](http://josh.github.com/nack/)都是。如果你的程序不需要Rails其他特性或者相关东西的话我力荐你使用它们，

Django also has [support for CoffeeScript](http://pypi.python.org/pypi/django-coffeescript/) through special template tags. It works with both inline code and external files.

Django通过特殊的模板标签也能[支持CoffeeScript](http://pypi.python.org/pypi/django-coffeescript/)。而且同时支持行内代码或者外联文件。

Both Ruby and Python pipe out to Node and the CoffeeScript lib behind the scenes when compiling CoffeeScript, so you'll need to have those installed during development. If you're using Node directly as a backend for your site, CoffeeScript integration is even simpler and you can use it for both the backend and frontend code. We're going to talk more about this in the next chapter, using [Stitch](https://github.com/sstephenson/stitch) to serve all our client-side CoffeeScript.

当需要编译CoffeeScript时，Ruby和Python在后台都是通过管道将其输出到Node和CoffeeScript库中，因此你在开发时需要事先安装好这些类库。如果你直接使用Node为你的站点开发后端程序，就非常容易集成CoffeeScript了，而且你还可以同时使用它来开发的前后台的代码。我们将在下一章介绍更多相关的东西，使用[Stitch](https://github.com/sstephenson/stitch)来为我们的客户端CoffeeScript提供服务。

