<div class="back"><a href="index.html">&laquo; 返回目录</a></div>

#Common CoffeeScript idioms
#CoffeeScript惯用法

Every language has a set of idioms and practices, and CoffeeScript is no exception. This chapter will explore those conventions, and show you some JavaScript to CoffeeScript comparisons so you can get a practical sense of the language. 

每个语言都有自己的惯用法和最佳实践，CoffeeScript也不例外。本章将为你揭示这些常规的东西，并且为你指出一些JavaScript到CoffeeScript的变化，以便你对这门语言有个感性的认识。

##Each
##Each

In JavaScript to iterate over every item in an array, we could either use the newly added [`forEach()`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/foreach) function, or an old C style `for` loop. If you're planning to use some of JavaScript's latest features introduced in ECMAScript 5, I advise you also include a [shim](https://github.com/kriskowal/es5-shim) in the page to emulate support in older browsers.

在JavaScript中我们既可以使用新加入的[`forEach()`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/foreach)也可以使用老的C语言风格的`for`循环来迭代一个数组。如果你打算使用一些在ECMAScript 5 提到的JavaScript新特性的话，我推荐你把这个 [shim](https://github.com/kriskowal/es5-shim) （薄层）来模拟这些特性以便支持老的浏览器。
    
    for (var i=0; i < array.length; i++)
      myFunction(array[i]);
      
    array.forEach(function(item, i){
      myFunction(item)
    });

Although the `forEach()` syntax is much more succinct and readable, it suffers from the drawback that the callback function will be invoked every iteration of the array, and is therefore much slower than the equivalent `for` loop. Let's see how it looks in CoffeeScript.

尽管`forEach()`语法非常简洁易读，但有个缺点是在每次数组迭代时都需要调用回调函数，因此它比等价的`for`循环要慢。让我看一下这CoffeeScirpt中又是什么样子。

<span class="csscript"></span>
      
    myFunction(item) for item in array
    
It's a readable and concise syntax, I'm sure you'll agree, and what's great is that it compiles to a `for` loop behind the scenes. In other words CoffeeScript's syntax offers the same expressiveness as `forEach()`, but without the speed and shimming caveats. 

这种语法易读简洁（我想你也这么认为），而且更棒的是这在背后会被编译为`for`循环。换句话说CoffeeScript的语法提供了`forEach()`的便捷，但是没有性能的损耗，也不需要shim的辅助。
    
##Map
##Map

As with `forEach()`, ES5 also includes a native map function that has a much more succinct syntax than the classic `for` loop, namely [`map()`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/map). Unfortunately it suffers from much the same caveats that `forEach()` does, its speed is greatly reduced due to the function calls.

与`forEach()`相同，ES5包含了一个比经典`for`循环在语法上更加简洁的函数，名为 [`map()`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/map)。不过它与`forEach()`有一样需要注意的地方，其运行速度仍会受到函数调用的拖累。

    var result = []
    for (var i=0; i < array.length; i++)
      result.push(array[i].name)

    var result = array.map(function(item, i){
      return item.name;
    });

As we covered in the syntax chapter, CoffeeScript's comprehensions can be used to get the same behavior as `map()`. Notice we're surrounding the comprehension with parens, which is **absolutely critical** in ensuring the comprehension returns what you'd expect, the mapped array. 

如我们在*语法*这一章所说，可以使用列表解析获得与`map()`同样的行为。注意最好使用括号把列表解析包裹起来，以便能够**完全地**确保列表解析返回你所想要的东西——映射后的数组。

<span class="csscript"></span>

    result = (item.name for item in array)

##Select
##筛选

Again, ES5 has a utility function [`filter()`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/filter) for reducing arrays:

ES5还提供了工具函数 [`filter()`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/filter) 来过滤数组：
    
    var result = []
    for (var i=0; i < array.length; i++)
      if (array[i].name == "test")
        result.push(array[i])

    result = array.filter(function(item, i){
      return item.name == "test"
    });

CoffeeScript's basic syntax uses the `when` keyword to filter items with a comparison. Behind the scenes a `for` loop is generated. The whole execution is performed in an anonymous function to ward against scope leakage and variable conflict. 

CoffeeScript的基础语法使用`when`关键字通过一个比较来过滤数组项。在背后会产生一个`for`循环，整个运行过程都包裹在一个匿名函数中，以防止作用域泄漏或变量冲突。

<span class="csscript"></span>

    result = (item for item in array when item.name is "test")

Don't forgot to include the parens, as otherwise `result` will be the last item in the array. 
别忘了使用括号，否则`result`是数组的最后一项。  
CoffeeScript's comprehensions are so flexible that they allow you to do powerful selections as in the following example:
CoffeeScript的列表解析是如此的灵活，允许你如下例这样做出强大地选择：

<span class="csscript"></span>

    passed = []
    failed = []
    (if score > 60 then passed else failed).push score for score in [49, 58, 76, 82, 88, 90]
    
    # Or
    passed = (score for score in scores when score > 60)
    
If comprehensions get too long, you can split them onto multiple lines.

如果列表解析太长，你可以将它们分割成多行。

<span class="csscript"></span>

    passed = []
    failed = []
    for score in [49, 58, 76, 82, 88, 90]
      (if score > 60 then passed else failed).push score

##Includes
##包含

Checking to see if a value is inside an array is typically done with `indexOf()`, which rather mind-bogglingly still requires a shim, as Internet Explorer hasn't implemented it. 

通常使用`indexOf()`来测试一个数组中是否包含某个值。不过真让人惊讶, Internet Explorer并没有实现该函数，这还要做一些兼容。

    var included = (array.indexOf("test") != -1)

CoffeeScript has a neat alternative to this which Pythonists may recognize, namely `in`.

于此CoffeeScript有一个非常给力的替代方法，Python程序员一定很熟悉，名叫`in`。

<span class="csscript"></span>
    
    included = "test" in array

Behind the scenes, CoffeeScript is using `Array.prototype.indexOf()`, and shimming if necessary, to detect if the value is inside the array. Unfortunately this  means the same `in` syntax won't work for strings. We need to revert back to using `indexOf()` and testing if the result is negative:

在背后，CoffeeScript使用的是 `Array.prototype.indexOf()`，必要的话提供shim方法来检测数组中是否有某个特定值，不幸的的是同样的`in`语法并不能在字符串中工作。我们退回去使用`indexOf()`函数，查看其返回值是否是负值：

<span class="csscript"></span>

    included = "a long test string".indexOf("test") isnt -1

Or even better, hijack the bitwise operator so we don't have to do a `-1` comparison. 

或者更好一点，借助于位操作符我们就不用与`-1`进行比较了。

<span class="csscript"></span>
    
    string   = "a long test string"
    included = !!~ string.indexOf "test"
    
##Property iteration
##属性迭代

To iterate over a bunch of properties in JavaScript, you'd use the `in` operator, for example:

在JavaScript中，你应该使用`in`操作符来迭代属性集，例如：

    var object = {one: 1, two: 2}
    for(var key in object) alert(key + " = " + object[key])
    
However, as you've seen in the previous section, CoffeeScript has already reserved `in` for use with arrays. Instead, the operator has been renamed `of`, and can be used like thus:

然而，如你在上一小节所知，CoffeeScript已把`in`关键字留给了数组用。作为替代，该操作符更名为`of`，可以像下面这样用：

<span class="csscript"></span>
    
    object = {one: 1, two: 2}
    alert("#{key} = #{value}") for key, value of object
    
As you can see, you can specify variables for both the property name, and its value; rather convenient.

如你所见，你可以同时指定属性名和属性值，非常方便。
    
##Min/Max
##Min/Max

This technique is not specific to CoffeeScript, but I thought it useful to demonstrate anyway. `Math.max` and `Math.min` take multiple arguments, so you can easily use `...` to pass an array to them, retrieving the maximum and minimum values in the array. 

这个技巧虽然不是CoffeeScript的专利，但是我觉得它非常有用，值得一提。`Math.max` 和`Math.min`接受多个参数，因此你可以简单的地使用`...`来向它们传递数组，从中检索出最大值和最小值。

<span class="csscript"></span>

    Math.max [14, 35, -7, 46, 98]... # 98
    Math.min [14, 35, -7, 46, 98]... # -7
    
It's worth noting that this trick will fail with really large arrays as browsers have a limitation on the amount of arguments you can pass to functions.

请注意，这个技巧对于超大的数组也会失败，因为浏览器对传递个函数的参数数量有限制。
    
##Multiple arguments
##多个参数

In the `Math.max` example above, we're  using `...` to de-structure the array and passing it as multiple arguments to `max`. Behind the scenes, CoffeeScript is converting the function call to use `apply()`, ensuring the array is passed as multiple arguments to `max`. We can use this feature in other ways too, such as proxying function calls:

在上面的`Math.max`示例中，我们使用`...`来结构数组作为多个参数传递给`max`方法。在背后，CoffeeScript将其转化为一个使用`appply()`的函数调用，以确保数组能够作为多个参数传递给`max`。在别的地方也可以使用这个特性，比方说代理函数：

<span class="csscript"></span>

    Log =
      log: ->
        console?.log(arguments...)
      
Or you can alter the arguments before they're passed onwards:

或者在参数继续传递下去之前，修改参数：

<span class="csscript"></span>

    Log =
      logPrefix: "(App)"

      log: (args...) ->
        args.unshift(@logPrefix) if @logPrefix
        console?.log(args...)
        
Bear in mind though, that CoffeeScript will automatically set the function invocation context to the object the function is being invoked on. In the example above, that would be `console`. If you want to set the context specifically, then you'll need to call `apply()` manually. 

不过请记住，CoffeeScript会自动把函数的调用上下文设置为调用它的对象。在上例中，就是`console`对象，如果你想设置特殊的上下文，那你需要手动的调用`apply()`方法。

##And/or
##And/or

CoffeeScript style guides indicates that `or` is preferred over `||`, and `and` is preferred over `&&`. I can see why, as the former is somewhat more readable. Nevertheless, the two styles have identical results.  

CoffeeScript编程风格推荐使用`or`代替`||`，使用`and`代替`&&`。我知道为什么，因为前者看起来更直观。不过，这两种编程风格产生的结果都一样。

This preference over more English style code also applies to using `is` over `==` and `isnt` over `!=`.

偏爱英语风格的代码的话，也可以使用`is`代替`==`，`isnt`代替`!=`。
    
<span class="csscript"></span>

    string = "migrating coconuts"
    string == string # true
    string is string # true
    
One extremely nice addition to CoffeeScript is the 'or equals', which is a pattern Rubyists may recognize as `||=`:

CoffeeScript还有另外一个非常好的扩展，Ruby程序员可将其看作像是`||=`这样的模式：
    
<span class="csscript"></span>

    hash or= {}
    
If hash evaluates to `false`, then it's set to an empty object. It's important to note here that this expression also recognizes `0`, `""` and `null` as false. If that isn't your intention, you'll need to use CoffeeScript's existential operator, which only gets activated if `hash` is `undefined` or `null`:

如果`hash`求值为`false`，则把它设置为一个空对象。在这里需要注意，表达式`0`、`""`和`null`都会被当作`false`。如果这并不是你想要的，那你应该使用CoffeeScript的存在操作符，这样只有`hash`是`undefined`或者`null`时才会触发。

<span class="csscript"></span>

    hash ?= {}

##Destructuring assignments
##解构赋值

Destructuring assignments can be used with any depth of array and object nesting, to help pull out deeply nested properties.

解构赋值对任意深度嵌套的数组或对象都适用，方便从嵌套的属性中抽取值。

<span class="csscript"></span>

    someObject = { a: 'value for a', b: 'value for b' }
    { a, b } = someObject
    console.log "a is '#{a}', b is '#{b}'"
    
This is especially useful in Node applications when requiring modules:

这在Node程序中引入模块时尤其有用：

<span class="csscript"></span>

    {join, resolve} = require('path')
    
    join('/Users', 'Alex')

##External libraries
##其他类库

Using external libraries is exactly the same as calling functions on CoffeeScript libraries; since at the end of the day everything is compiled down to JavaScript. Using CoffeeScript with [jQuery](http://jquery.com) is especially elegant, due to the amount of callbacks in jQuery's API. 

既然所有的东西都会编译为JavaScript，那么使用其他类库与调用CoffeeScript类库的函数并没有什么差别。在CoffeeScript中使用 [jQuery](http://jquery.com)显得非常优雅，因为jQuery的API中有很多回调函数。

<span class="csscript"></span>

    # Use local alias
    $ = jQuery

    $ ->
      # DOMContentLoaded
      $(".el").click ->
        alert("Clicked!")
    
Since all of CoffeeScript's output is wrapped in an anonymous function, we can set a local `$` alias for `jQuery`. This will make sure that even if jQuery's no conflict mode is enabled and the `$` re-defined, our script will still function as intended. 

既然CoffeeScript编译输出的所有代码都被包裹在一个匿名函数中，因此我们可以使用一个局部变量`$`来代替`jQuery`。就算在jQuery的`no confict`模式或者`$`被重定义的情况下，我们的脚本能按预想的一样正常工作。

##Private variables
##私有变量

The `do` keyword in CoffeeScript lets us execute functions immediately, a great way of encapsulating scope & protecting variables. In the example below, we're defining a variable `classToType` in the context of an anonymous function which's immediately called by `do`. That anonymous function returns a second anonymous function, which will be ultimate value of `type`. Since `classToType` is defined in a context that no reference is kept to, it can't be accessed outside that scope.

CoffeeScript中的`do`关键字能够让我们立即运行函数，这是一种非常有效的包装作用域和受保护变量的方式。在下面的例子中，我在被`do`立刻调用的匿名函数的上下文中定义了一个变量`classToType`。该匿名函数返回了另外一个匿名函数，它才是`type`最终的值。既然`classType`是在一个不保存引用的上下文中，因此在外部作用域中不可访问。

<span class="csscript"></span>

    # Execute function immediately
    type = do ->
      classToType = {}
      for name in "Boolean Number String Function Array Date RegExp Undefined Null".split(" ")
        classToType["[object " + name + "]"] = name.toLowerCase()
      
      # Return a function
      (obj) ->
        strType = Object::toString.call(obj)
        classToType[strType] or "object"

In other words, `classToType` is completely private, and can never again be referenced outside the executing anonymous function. This pattern is a great way of encapsulating scope and hiding variables.

换句话说，`classToType`是完全私有的，并且在匿名函数执行完毕之后就不能在外面作用域中引用它了。这是一种非常好的包装作用域和变量的办法。
